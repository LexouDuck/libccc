<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>comment</key>
	<string>https://github.com/abusalimov/SublimeCImproved
https://github.com/lexouduck/libccc
  This is the ++C syntax coloring regex/lex rules, in sublime-syntax format
  which is derived from CImproved.tmLanguage - the Sublime Text syntax definition plugin package,
  which is derived from C.tmLanguage - the original TextMate and Sublime Text syntax definition.
</string>
	<key>fileTypes</key>
	<array>
		<string>c</string>
		<string>h</string>
		<string>C</string>
		<string>H</string>
		<string>++c</string>
		<string>++h</string>
		<string>++C</string>
		<string>++H</string>
		<string>ppc</string>
		<string>pph</string>
		<string>ppC</string>
		<string>ppH</string>
		<string>PPc</string>
		<string>PPh</string>
		<string>PPC</string>
		<string>PPH</string>
		<string>xxc</string>
		<string>xxh</string>
		<string>xxC</string>
		<string>xxH</string>
		<string>XXc</string>
		<string>XXh</string>
		<string>XXC</string>
		<string>XXH</string>
	</array>
	<key>firstLineMatch</key>
	<string>-[*]-( Mode:)? C -[*]-</string>
	<key>name</key>
	<string>++C</string>
	<key>patterns</key>
	<array>
		<dict>
			<key>include</key>
			<string>#translation_unit</string>
		</dict>
	</array>
	<key>repository</key>
	<dict>
		<key>block</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>(?=\{)</string>
				<key>end</key>
				<string>\}</string>
				<key>patterns</key>
				<array>
					<dict>
						<key>include</key>
						<string>#block-lookahead-end</string>
					</dict>
				</array>
			</dict>
		</dict>
		<key>block-lookahead-end</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\{</string>
					<key>end</key>
					<string>(?=\})</string>
					<key>name</key>
					<string>meta.block.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#typedef</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#lex-type</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#lex</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#support</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#function</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable-declaration</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#macro</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#ppline-macro-operator</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$base</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>block-special</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>(?x)
  (?= \s*
    (?:
        (?: \b extern \b
            (?: "(\\.|[^"])*" | '(\\.|[^'])*' | /\*.*?\*/ | \s)*
        )
        |
        (?: \b namespace \b
            (?: (?: /\*.*?\*/ | \s)* \b [A-Za-z_]\w*+ \b)?
            (?: /\*.*?\*/ | \s)*
        )
    )
    \{
  )</string>
				<key>end</key>
				<string>\}</string>
				<key>patterns</key>
				<array>
					<dict>
						<key>include</key>
						<string>#lex</string>
					</dict>
					<dict>
						<key>begin</key>
						<string>\{</string>
						<key>end</key>
						<string>(?=\})</string>
						<key>name</key>
						<string>meta.block.special.c</string>
						<key>patterns</key>
						<array>
							<dict>
								<key>include</key>
								<string>$base</string>
							</dict>
						</array>
					</dict>
				</array>
			</dict>
		</dict>
		<key>comment</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#comment-note</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#comment-banner-line</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-continuation</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-newline</string>
				</dict>
			</array>
		</dict>
		<key>comment-banner-line</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>(?:(?&lt;=/[/\*])|^)[\s/*]*(=+\s*(.*?)\s*=+(?:(?=[\s/*+\-]*\*/)|$(\n?)))</string>
				<key>beginCaptures</key>
				<dict>
					<key>1</key>
					<dict>
						<key>name</key>
						<string>meta.toc-list.banner.c</string>
					</dict>
					<key>3</key>
					<dict>
						<key>name</key>
						<string>punctuation.whitespace.newline.c</string>
					</dict>
				</dict>
			</dict>
		</dict>
		<key>comment-command</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>comment.c</string>
						</dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>comment.command.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\b(?:[A-Za-z_]\w+)(\(\))</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>comment.c</string>
						</dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>comment.command.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\b(#)(?:[A-Za-z_]\w+)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>comment.command.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>@[{}]</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>comment.command.c</string>
						</dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>comment.command.user.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>comment.command.c</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>comment.command.user.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?ix)
  (?= (?-i: [@\\][A-Za-z_]++) \b) [@\\]? \b
  ( GROUP
  | ALIAS
  | ARG
  | ISOSTD
  | NONSTD
  | ERRORS
  | PARAM_ENV
  | PARAM_WORKER
  | PARAM_RESULT
  | (?:END)?EXAMPLES
  | (?:END)?EXAMPLECODE
  ) \b
  ({([^}]*)})?</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(?ix)
    [@\\] \b
    ( ({) | (})
    | A
    | ADDTOGROUP
    | ANCHOR
    | B
    | C
    | CATEGORY
    | CITE
    | CLASS
    | COPYBRIEF
    | COPYDETAILS
    | COPYDOC
    | DEF
    | DEFGROUP
    | DIAFILE
    | DIR
    | DOCBOOKINCLUDE
    | DONTINCLUDE
    | DOTFILE
    | E
    | EM
    | ENUM
    | EXAMPLE
    | FILE
    | HEADERFILE
    | HTMLINCLUDE
    | IDLEXCEPT
    | IMPLEMENTS
    | INCLUDE
    | INCLUDEDOC
    | INCLUDELINENO
    | INGROUP
    | INTERFACE
    | LATEXINCLUDE
    | LINK
    | MANINCLUDE
    | MEMBEROF
    | MSCFILE
    | NAMESPACE
    | P
    | PACKAGE
    | PAGE
    | PAR
    | PARAM
    | PARAGRAPH
    | PROTOCOL
    | REF
    | REFITEM
    | RELATED
    | RELATES
    | RELATEDALSO
    | RELATESALSO
    | RTFINCLUDE
    | SNIPPET
    | SNIPPETDOC
    | SNIPPETLINENO
    | STRUCT
    | SUBPAGE
    | SUBSECTION
    | SUBSUBSECTION
    | TYPEDEF
    | UNION
    | VAR
    | VERBINCLUDE
    | WEAKGROUP
    | XMLINCLUDE
    ) \b
    [\t\ ]*([^\s]+)</string>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>comment.command.c</string>
						</dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>comment.command.doxygen.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>comment.command.doxygen.group-brace.c</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>comment.command.doxygen.group-close.c</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>comment.command.user.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?ix)
  [@\\] \b
  (?:
    ( ({) | (})
    | ADDINDEX
    | ARG
    | ATTENTION
    | AUTHOR
    | AUTHORS
    | BRIEF
    | BUG
    | CALLERGRAPH
    | CALLGRAPH
    | CODE
    | COND
    | COPYRIGHT
    | DATE
    | DEPRECATED
    | DETAILS
    | DOCBOOKONLY
    | DOT
    | ELSE
    | ELSEIF
    | EMOJI
    | ENDCODE
    | ENDCOND
    | ENDDOCBOOKONLY
    | ENDDOT
    | ENDHTMLONLY
    | ENDIF
    | ENDINTERNAL
    | ENDLATEXONLY
    | ENDLINK
    | ENDMANONLY
    | ENDMSC
    | ENDPARBLOCK
    | ENDRTFONLY
    | ENDSECREFLIST
    | ENDVERBATIM
    | ENDUML
    | ENDXMLONLY
    | EXCEPTION
    | EXTENDS
    | FN
    | FILE
    | HIDECALLERGRAPH
    | HIDECALLGRAPH
    | HIDEREFBY
    | HIDEREFS
    | HIDEINITIALIZER
    | HTMLONLY
    | IF
    | IFNOT
    | IMAGE
    | INTERNAL
    | INVARIANT
    | LATEXONLY
    | LI
    | LINE
    | MAINPAGE
    | MANONLY
    | MSC
    | N
    | NAME
    | NOOP
    | NOSUBGROUPING
    | NOTE
    | OVERLOAD
    | PARBLOCK
    | POST
    | PRE
    | PRIVATE
    | PRIVATESECTION
    | PROPERTY
    | PROTECTED
    | PROTECTEDSECTION
    | PUBLIC
    | PUBLICSECTION
    | PURE
    | REMARK
    | REMARKS
    | RESULT
    | RETURN
    | RETURNS
    | RETVAL
    | RTFONLY
    | SA
    | SECREFLIST
    | SECTION
    | SEE
    | SHORT
    | SHOWINITIALIZER
    | SHOWREFBY
    | SHOWREFS
    | SINCE
    | SKIP
    | SKIPLINE
    | STATIC
    | STARTUML
    | TABLEOFCONTENTS
    | TEST
    | THROW
    | THROWS
    | TODO
    | TPARAM
    | UNTIL
    | VERBATIM
    | VERSION
    | VHDLFLOW
    | WARNING
    | XMLONLY
    | XREFITEM
    ) \b |
    ( F[\$\[\]\{\}]
    | \$
    | \@
    | \\
    | \&amp;
    | \~
    | \&lt;
    | \=
    | \&gt;
    | \#
    | \%
    | \"
    | \.
    | \|
    | ::
    | --
    | ---
    )
  )</string>
				</dict>
			</array>
		</dict>
		<key>comment-documentation</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#comment-note</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#comment-command</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-continuation</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-newline</string>
				</dict>
			</array>
		</dict>
		<key>comment-note</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>comment.command.c</string>
						</dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>storage.type.class.note.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?=[\s/*]*\*/)|(?&lt;=$\n)</string>
					<key>match</key>
					<string>(?ix)
    (?= (?-i: \b [A-Z_]++) \b) @? \b
    ( TODO
    | NOTE
    | NB
    | TBD
    | REVIEW
    | CHANGED
    | IDEA
    | IMPORTANT
    | HACK
    | BUG
    | DEPRECATED
    ) \b</string>
					<key>name</key>
					<string>meta.toc-list.task-tag.note.c</string>
				</dict>
			</array>
		</dict>
		<key>end</key>
		<string>(?&lt;=\()(?:\s*\*\s*)([A-Za-z_]\w*+)(?:\s*\)\s*\()(;)</string>
		<key>endCaptures</key>
		<dict>
			<key>1</key>
			<dict>
				<key>name</key>
				<string>entity.name.variable.c</string>
			</dict>
			<key>2</key>
			<dict>
				<key>name</key>
				<string>punctuation.terminator.c</string>
			</dict>
		</dict>
		<key>function</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#function-pointer</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#function-declaration</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#function-definition</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#function-call-macro</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#function-call</string>
				</dict>
			</array>
		</dict>
		<key>function-call</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>end</key>
					<string>\)</string>
					<key>match</key>
					<string>(?x)
  \s*\b
  (?= # don't consume string, to recognize support functions
      (?: [A-Za-z_]\w*+ | ::[^:] | \. )++
      (?: \s|/\*.*?\*/)*+
      \(
  )</string>
					<key>name</key>
					<string>meta.function-call.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#lex</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#support-function</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>\b(?:([A-Za-z_]\w*+)|(::[^:]|\.|-&gt;))++\b</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>variable.function.c</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>punctuation.accessor.c</string>
								</dict>
							</dict>
							<key>match</key>
							<string>(?:(?&lt;=\.)|(?&lt;=-&gt;))\b([A-Za-z_]\w*+)\b</string>
							<key>name</key>
							<string>variable.function.access.c</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#parens-lookahead-end</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>function-call-macro</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?x)
  \s*\b
  (?= # don't consume string, to recognize support functions
    (?: [_A-Z][_A-Z0-9]*+)
    (?: \s|/\*.*?\*/)*+
    \(
  )</string>
					<key>end</key>
					<string>\)</string>
					<key>name</key>
					<string>meta.function-call.constant.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#lex</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#support-macro</string>
						</dict>
						<dict>
							<key>captures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>variable.function.constant.c</string>
								</dict>
							</dict>
							<key>match</key>
							<string>\b([_A-Z][_A-Z0-9]*+)\b</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#parens-lookahead-end</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>function-declaration</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?x)
  (?: (?&lt;! (?&lt;!\w) new
        | (?&lt;!\w) (?:else|enum)
        | (?&lt;!\w) (?:class|union)
        | (?&lt;!\w) (?:struct|return|sizeof|typeof)
        | (?&lt;!\w) __typeof | (?&lt;!\w) __typeof__
      )
      (?&lt;= \w\b)
    | #  or type modifier / closing bracket before name
      (?&lt;= [*&gt;)}\]] )
  )
  \s*+
  (   (?: [A-Za-z_]\w*+ | ::[^:] | \. )++ )
  (?=
    (?:\s|/\*.*?\*/)*+
    (?'parens' \(
      (?&gt; \g'parens'
        | "(\\.|[^"])*"
        | '(\\.|[^'])*'
        | /\*.*?\*/
        | (?! /[/*] | [()] ) .
      )*
      \)
    )
    \s*;
  )</string>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>entity.name.function.declaration.c</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.function.declaration.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#lex</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#parens</string>
						</dict>
						<dict>
							<key>match</key>
							<string>(;)</string>
							<key>name</key>
							<string>punctuation.terminator.c</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>function-definition</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?x)
  (?: (?&lt;! (?&lt;!\w) new
        | (?&lt;!\w) (?:else|enum)
        | (?&lt;!\w) (?:class|union)
        | (?&lt;!\w) (?:struct|return|sizeof|typeof)
        | (?&lt;!\w) __typeof | (?&lt;!\w) __typeof__
      )
      (?&lt;= \w\b)
    | #  or type modifier / closing bracket before name
      (?&lt;= [*&gt;)}\]] )
  )
  \s*+
  (   (?: [A-Za-z_]\w*+ | ::[^:] | \. )++ )
  (?=
    (?:\s|/\*.*?\*/)*+
    \(
  )</string>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>entity.name.function.definition.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\}|;)</string>
					<key>name</key>
					<string>meta.function.definition.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#lex</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#parens</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#block-lookahead-end</string>
						</dict>
						<dict>
							<key>match</key>
							<string>\s*\b(const|override)\b</string>
							<key>name</key>
							<string>storage.modifier.c</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>function-pointer</key>
		<false/>
		<key>lex</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#lex-core</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#preprocessor</string>
				</dict>
			</array>
		</dict>
		<key>lex-access</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(?:(?&lt;=\.)|(?&lt;=-&gt;))\b([A-Za-z_]\w*+)\b(?!(?:\s|/\*.*?\*/)*+\()</string>
					<key>name</key>
					<string>variable.other.member-access.c</string>
				</dict>
			</array>
		</dict>
		<key>lex-comment</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\s*(/\*)([*!])</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.block.documentation.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>comment.command</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\*/)</string>
					<key>name</key>
					<string>comment.block.documentation.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#comment-documentation</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\s*(//)([/!]&lt;?)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.line.documentation.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>comment.command</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
					<key>name</key>
					<string>comment.line.documentation.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#comment-documentation</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\s*(/\*)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.block.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\*/)</string>
					<key>name</key>
					<string>comment.block.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.line.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
					<key>match</key>
					<string>\s*(//)</string>
					<key>name</key>
					<string>comment.line.++c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#comment</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>match</key>
					<string>\*/(?![/*])</string>
					<key>name</key>
					<string>invalid.illegal.stray-comment-end.c</string>
				</dict>
			</array>
		</dict>
		<key>lex-constant</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\s*\b(null|true|false|ERROR|OK)\b</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.language.++c</string>
						</dict>
					</dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.language.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(NULL|TRUE|FALSE)\b</string>
				</dict>
			</array>
		</dict>
		<key>lex-continuation</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.line-continuation.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>punctuation.whitespace.newline.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(\\)$(\n?)</string>
					<key>name</key>
					<string>punctuation.separator.continuation.c</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>invalid.deprecated.space-after-continuation.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\\(\s+?)(?=\n)$</string>
				</dict>
			</array>
		</dict>
		<key>lex-core</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#lex-comment</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-access</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-continuation</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-newline</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-literal-number</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-literal-string</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-literal-regex</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-keyword</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-storage</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-operator</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-constant</string>
				</dict>
			</array>
		</dict>
		<key>lex-keyword</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b((?:__|(?!\w+__))asm(?:__)?|break|case|continue|default|do|else|for|goto|if|_Pragma|return|switch|typedef|while|__extension__)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.control.++c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(foreach)\b</string>
				</dict>
			</array>
		</dict>
		<key>lex-literal-number</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.prefix.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.number.missing-fragment.significand.c</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.whole-number.c</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.fraction.c</string>
						</dict>
						<key>5</key>
						<dict>
							<key>name</key>
							<string>keyword.other.exponent.hexadecimal.c</string>
						</dict>
						<key>6</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.exponent.c</string>
						</dict>
						<key>7</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.exponent.c</string>
						</dict>
						<key>8</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.number.missing-fragment.exponent.c</string>
						</dict>
						<key>9</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.suffix.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?ix)  # hexadecimal float literal
  (?&lt;!\.) \b

  (0x)

  # significand
  (?: (\.) (?=p)  # invalid
    |        [0-9a-f]*+ ([0-9a-z]*?) [0-9a-f]*+
      (?: \. [0-9a-f]*+ ([0-9a-z.]*?) [0-9a-f]*+ )? )

  # exponent (required)
  (?: (p) (?:        [+\-]  [0-9]++ ([0-9a-z]*?)
            | (?=[0-9a-z.]) [0-9]*+ ([0-9a-z.]*?) )
    | (p) )

  # remaining valid chars and type specifier suffix
  [0-9]*+ ([fl]?)

  \b (?!\.)</string>
					<key>name</key>
					<string>constant.numeric.float.hexadecimal.c</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.prefix.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.whole-number.c</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.number.hexadecimal-float-requires-exponent.c</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.fraction.c</string>
						</dict>
						<key>5</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.suffix.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?ix)  # hexadecimal float literal, without required exponent
  (?&lt;!\.) \b

  (0x)

  # significand (at least a period)
       [0-9a-f]*+ ([0-9a-z&amp;&amp;[^p]]*?) [0-9a-f]*+
  (\.) [0-9a-f]*+ ([0-9a-z.&amp;&amp;[^p]]*?) [0-9a-f]*+

  # type specifier suffix
  (l?)

  (?:(?&lt;=\.)|\b) (?!\.)</string>
					<key>name</key>
					<string>constant.numeric.float.hexadecimal.c</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.whole-number.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.fraction.c</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.whole-number.c</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>keyword.other.exponent.decimal.c</string>
						</dict>
						<key>5</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.exponent.c</string>
						</dict>
						<key>6</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.exponent.c</string>
						</dict>
						<key>7</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.exponent.c</string>
						</dict>
						<key>8</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.float.exponent.c</string>
						</dict>
						<key>9</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.suffix.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?ix)  # decimal float literal
  (?&lt;!\.) (?:(?=\.)|\b)

  (?!0x)
  # significand
  (?: (?: [0-9]++ ([0-9a-z&amp;&amp;[^e]]*?) [0-9]*+ )?
      \.  [0-9]++ ([0-9a-z.&amp;&amp;[^e]]*?) [0-9]*+

    |     [0-9]++ ([0-9a-z&amp;&amp;[^e]]*?) [0-9]*+ (?: \. | (?=e)) )

  # exponent (optional)
  (?: (e) (?: [+\-]  [0-9]++ ([0-9a-z]*?)
            |        [0-9]++ ([0-9a-z.]*?) )
    | ( p     [+\-]? [0-9]++
      | [ep]                  [0-9a-z.]*?) )?

  # any invalid chars and type specifier suffix
  ([0-9a-z]*?) [0-9]*+ ([fl]?)

  (?:(?&lt;=\.)|\b) (?!\.)</string>
					<key>name</key>
					<string>constant.numeric.float.c</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.prefix.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.suffix.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?ix) # zero
  (?&lt;!\.)
  \b
  (0[xbo])?           # literal prefix
  0++                 # iterate over number characters
  (u?l{0,2}|lul?|llu) # type specifier suffix, if any
  \b
  (?!\.)</string>
					<key>name</key>
					<string>constant.numeric.integer.zero.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(?ix) # invalid (empty) number literal
  (?&lt;!\.)
  \b
  (?: (0x) | (0b) )   # literal prefix
  (u?l{0,2}|lul?|llu) # type specifier suffix, if any
  \b
  (?!\.)</string>
					<key>name</key>
					<string>invalid.illegal.invalid-number-literal.c</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.prefix.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.integer.c</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.suffix.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?ix) # hexadecimal integer literal
  (?&lt;!\.)
  \b
  (0x)                # literal prefix
  [0-9a-f]++          # iterate over number characters
  ([0-9a-z]*?)        # find any invalid chars
  [0-9a-f]*           # the remainder (after invalid chars, if any)
  (u?l{0,2}|lul?|llu) # type specifier suffix, if any
  \b
  (?!\.)</string>
					<key>name</key>
					<string>constant.numeric.integer.hexadecimal.c</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.prefix.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.integer.c</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.suffix.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?ix) # binary integer literal
  (?&lt;!\.)
  \b
  (0b)                # literal prefix
  [01]++              # iterate over number characters
  ([0-9a-z]*?)        # find any invalid chars
  [01]*               # the remainder (after invalid chars, if any)
  (u?l{0,2}|lul?|llu) # type specifier suffix, if any
  \b
  (?!\.)</string>
					<key>name</key>
					<string>constant.numeric.integer.binary.c</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.prefix.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.integer.c</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.suffix.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?ix) # octal integer literal
  (?&lt;!\.)
  \b
  (0|0o)              # literal prefix
  [0-7]++             # iterate over number characters
  ([0-9a-z]*?)        # find any invalid chars
  [0-7]*              # the remainder (after invalid chars, if any)
  (u?l{0,2}|lul?|llu) # type specifier suffix, if any
  \b
  (?!\.)</string>
					<key>name</key>
					<string>constant.numeric.integer.octal.c</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.numeric-literal-character.integer.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>constant.numeric.other.suffix.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?ix) # decimal integer literal
  (?&lt;!\.)
  \b
  [0-9]++             # iterate over number characters
  ([0-9a-z]*?)        # find any invalid chars
  [0-9]*              # the remainder (after invalid chars, if any)
  (u?l{0,2}|lul?|llu) # type specifier suffix, if any
  \b
  (?!\.)</string>
					<key>name</key>
					<string>constant.numeric.integer.decimal.c</string>
				</dict>
			</array>
		</dict>
		<key>lex-literal-regex</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(?&lt;!\+\+|--|})(?&lt;=[=(:,\[?+!]|^return|[^\._$[:alnum:]]return|^case|[^\._$[:alnum:]]case|=&gt;|&amp;&amp;|\|\||\*\/)\s*(r\")(?![\/*])(?=(?:[^\/\\\[\()]|\\.|\[([^\]\\]|\\.)+\]|\(([^\)\\]|\\.)+\))+\"([gimsuy]+|(?![\/\*])|(?=\/\*))(?!\s*[a-zA-Z0-9_$]))</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\")([gimsuy]*)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.other.c</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.regexp.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#regexp</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\")([gimsuy]*)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.other.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>((?&lt;![_$[:alnum:])\]]|\+\+|--|}|\*\/)|((?&lt;=^return|[^\._$[:alnum:]]return|^case|[^\._$[:alnum:]]case))\s*)r\"(?![\/*])(?=(?:[^\/\\\[]|\\.|\[([^\]\\]|\\.)+\])+\"([gimsuy]+|(?![\/\*])|(?=\/\*))(?!\s*[a-zA-Z0-9_$]))</string>
					<key>name</key>
					<string>string.regexp.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#regexp</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>lex-literal-string</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>"</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>'</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.c</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.double.c</string>
					<key>patterns</key>
					<dict>
						<key>end</key>
						<string>(')|(?&lt;=^|[^\\])\s*(\n)</string>
						<key>endCaptures</key>
						<dict>
							<key>1</key>
							<dict>
								<key>name</key>
								<string>punctuation.definition.string.end.c</string>
							</dict>
							<key>2</key>
							<dict>
								<key>name</key>
								<string>invalid.illegal.unexpected-end-of-line.c</string>
							</dict>
						</dict>
						<key>patterns</key>
						<array>
							<dict>
								<key>include</key>
								<string>#lex-continuation</string>
							</dict>
							<dict>
								<key>include</key>
								<string>#string-escape-sequence</string>
							</dict>
						</array>
					</dict>
				</dict>
			</array>
		</dict>
		<key>lex-newline</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>$\n</string>
					<key>name</key>
					<string>punctuation.whitespace.newline.c</string>
				</dict>
			</array>
		</dict>
		<key>lex-operator</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(\.|-&gt;)(?=(?:\s|/\*.*?\*/)*+[A-Za-z_]\w*+)</string>
					<key>name</key>
					<string>punctuation.accessor.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(\-|\+|\*|\/|%|&amp;|\||\^|&lt;&lt;|&gt;&gt;)?=</string>
					<key>name</key>
					<string>keyword.operator.assignment.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(==|!=|&lt;=|&gt;=|&lt;&gt;|&lt;|&gt;)</string>
					<key>name</key>
					<string>keyword.operator.comparison.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(\-\-)</string>
					<key>name</key>
					<string>keyword.operator.decrement.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(\+\+)</string>
					<key>name</key>
					<string>keyword.operator.increment.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(\?|:)</string>
					<key>name</key>
					<string>keyword.operator.ternary.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(\-|\+|\*|\/|%)</string>
					<key>name</key>
					<string>keyword.operator.arithmetic.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(!|&amp;&amp;|\|\|)</string>
					<key>name</key>
					<string>keyword.operator.logical.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(~|&amp;|\||\^|&lt;&lt;|&gt;&gt;)</string>
					<key>name</key>
					<string>keyword.operator.bitwise.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(\.\.\.)</string>
					<key>name</key>
					<string>keyword.operator.variadic.c</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.word.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(compl|not|not_eq|and|and_eq|or|or_eq|xor|xor_eq|bitand|bitor)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.word.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(sizeof|defined)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.word.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(_Alignof|__alignof|__alignof__|__typeof|__typeof__)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.word.++c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(alignof|typeof|nameof)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.custom.++c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b([\=\-\+\*\/\%\&amp;\|\^\!\~\?\:\&lt;\&gt;\$\@])\b</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(\*|\$)(?=[A-Za-z_]\w*)</string>
					<key>name</key>
					<string>keyword.operator.getvalue.++c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>(\&amp;|\@)(?=[A-Za-z_]\w*)</string>
					<key>name</key>
					<string>keyword.operator.getaddress.++c</string>
				</dict>
			</array>
		</dict>
		<key>lex-preprocessor</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#lex-comment</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-continuation</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-newline</string>
				</dict>
			</array>
		</dict>
		<key>lex-storage</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>storage.modifier.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(auto|extern|static|register|__attribute__|(?:__|(?!\w+__))(?:const|restrict|volatile|inline)(?:__)?)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.declaration.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(class|struct|union|enum)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>storage.type.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(bool|_Bool|char|_Complex|double|float|_Imaginary|int|long|short|signed|unsigned|void)\b</string>
				</dict>
			</array>
		</dict>
		<key>lex-type</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#type-declaration</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#type-definition</string>
				</dict>
			</array>
		</dict>
		<key>macro</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>variable.language.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\b(__VA_ARGS__)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>variable.other.constant.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\b(__\w++(?:__)?)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>variable.other.constant.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\b([_A-Z][_A-Z0-9]++)\b</string>
				</dict>
			</array>
		</dict>
		<key>parens</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>(?=\()</string>
				<key>end</key>
				<string>\)</string>
				<key>patterns</key>
				<array>
					<dict>
						<key>include</key>
						<string>#parens-lookahead-end</string>
					</dict>
				</array>
			</dict>
		</dict>
		<key>parens-lookahead-end</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>end</key>
					<string>(?=\))</string>
					<key>match</key>
					<string>\(</string>
					<key>name</key>
					<string>meta.parens.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#lex-type</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#lex</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#support</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#function-pointer</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#function-call-macro</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#function-call</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable-declaration</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#macro</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#variable</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#ppline-macro-operator</string>
						</dict>
						<dict>
							<key>include</key>
							<string>$base</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>ppline-any</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>^\s*(#)</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
					<key>name</key>
					<string>meta.preprocessor.directive.null-directive.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#lex-core</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>ppline-directive</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>^\s*(#)\s*(if|ifdef|ifndef|elif|else|endif|pragma|line|define|undef|error|warning)\b</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
					<key>name</key>
					<string>meta.preprocessor.directive.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#lex-core</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#macro</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>^\s*(#)\s*(namespace|function|operator|accessor|incbin|header|reflect|alias|align|inline|format|noreturn|malloc|delete|packed|pure)\b</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>keyword.other.preprocessor.++c</string>
								</dict>
							</dict>
							<key>end</key>
							<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
							<key>name</key>
							<string>meta.preprocessor.directive.++c</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#lex-core</string>
								</dict>
								<dict>
									<key>begin</key>
									<string>^\s*(#)\s*(replace)\b</string>
									<key>beginCaptures</key>
									<dict>
										<key>0</key>
										<dict>
											<key>name</key>
											<string>keyword.other.preprocessor.include.c</string>
										</dict>
									</dict>
									<key>end</key>
									<string>(?:("[^"]*?)|(&lt;[^&gt;]*?))(\n)|(?&lt;=$\n)(?&lt;!\\$\n)</string>
									<key>endCaptures</key>
									<dict>
										<key>1</key>
										<dict>
											<key>name</key>
											<string>string.quoted.double.include.c</string>
										</dict>
										<key>2</key>
										<dict>
											<key>name</key>
											<string>string.quoted.other.lt-gt.include.c</string>
										</dict>
										<key>3</key>
										<dict>
											<key>name</key>
											<string>invalid.illegal.unexpected-end-of-line.c</string>
										</dict>
									</dict>
									<key>name</key>
									<string>meta.preprocessor.include.c meta.preprocessor.c.include</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#ppline-include-innards</string>
										</dict>
									</array>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>ppline-directive-invalid-usage</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.c</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.invalid-usage-of-preprocessor-directive.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(^\s*(#)\s*(if|ifdef|ifndef|elif|pragma|define|undef|include|include_next|import)\b)\s*?(\n|$)</string>
					<key>name</key>
					<string>meta.preprocessor.directive.c</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.c</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.invalid-usage-of-preprocessor-directive.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(^\s*(#)\s*(operator|accessor|replace|alias|align|incbin)\b)\s*?(\n|$)</string>
					<key>name</key>
					<string>meta.preprocessor.directive.c</string>
				</dict>
			</array>
		</dict>
		<key>ppline-directive-obsolete</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>^\s*(#)\s*(assert|unassert|ident|sccs)\b</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.deprecated.preprocessor.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
					<key>name</key>
					<string>meta.preprocessor.directive.deprecated.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#lex-core</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>ppline-include</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>^\s*(#)\s*(include|include_next|import)\b</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.include.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?:("[^"]*?)|(&lt;[^&gt;]*?))(\n)|(?&lt;=$\n)(?&lt;!\\$\n)</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>string.quoted.double.include.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>string.quoted.other.lt-gt.include.c</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.unexpected-end-of-line.c</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.preprocessor.include.c meta.preprocessor.c.include</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#ppline-include-innards</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>ppline-include-innards</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#lex-preprocessor</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>"|(?=.*?")</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.begin.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>"|(?&lt;=^|[^\\])(?=\s*\n)</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.string.end.c</string>
						</dict>
					</dict>
					<key>name</key>
					<string>string.quoted.double.include.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>&lt;(?=.*?&gt;)</string>
							<key>beginCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.string.begin.c</string>
								</dict>
							</dict>
							<key>end</key>
							<string>&gt;|(?&lt;=^|[^\\])(?=\s*\n)</string>
							<key>endCaptures</key>
							<dict>
								<key>0</key>
								<dict>
									<key>name</key>
									<string>punctuation.definition.string.end.c</string>
								</dict>
							</dict>
							<key>name</key>
							<string>string.quoted.other.lt-gt.include.c</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>begin</key>
									<string>\(</string>
									<key>end</key>
									<string>\)|(?&lt;=^|[^\\])(?=\s*\n)</string>
									<key>name</key>
									<string>meta.parens.c</string>
									<key>patterns</key>
									<array>
										<dict>
											<key>include</key>
											<string>#ppline-include-innards</string>
										</dict>
									</array>
								</dict>
							</array>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>ppline-invalid</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>invalid.illegal.preprocessor.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
					<key>match</key>
					<string>^\s*(#)(?!\s*(?=/[/*]|(?&gt;\\\s*\n)|\n|$))\s*(\w*)</string>
					<key>name</key>
					<string>meta.preprocessor.directive.illegal.c</string>
				</dict>
			</array>
		</dict>
		<key>ppline-macro</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
					<key>match</key>
					<string>^\s*(#)(?=\s*(define)\s+[A-Za-z_]\w*+)</string>
					<key>name</key>
					<string>meta.preprocessor.macro.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#ppline-macro-head-function</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#ppline-macro-head-object</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#lex-core</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#ppline-macro-operator</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#function</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#support</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#block</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#parens</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#macro</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>ppline-macro-head-function</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>(?&lt;!##)(?&lt;=#)(\s*define)\s+([A-Za-z_]\w*+)(\()</string>
				<key>beginCaptures</key>
				<dict>
					<key>1</key>
					<dict>
						<key>name</key>
						<string>keyword.other.preprocessor.define.c</string>
					</dict>
					<key>2</key>
					<dict>
						<key>name</key>
						<string>entity.name.function.preprocessor.c</string>
					</dict>
					<key>3</key>
					<dict>
						<key>name</key>
						<string>meta.preprocessor.macro.parameters.c</string>
					</dict>
				</dict>
				<key>contentName</key>
				<string>meta.preprocessor.macro.parameters.c</string>
				<key>end</key>
				<string>(?&lt;=\))|(?&lt;=^|[^\\])\s*(\n)</string>
				<key>endCaptures</key>
				<dict>
					<key>1</key>
					<dict>
						<key>name</key>
						<string>invalid.illegal.unexpected-end-of-line.c</string>
					</dict>
				</dict>
				<key>patterns</key>
				<array>
					<dict>
						<key>begin</key>
						<string>\b([A-Za-z_]\w*+)\b</string>
						<key>beginCaptures</key>
						<dict>
							<key>1</key>
							<dict>
								<key>name</key>
								<string>variable.parameter.c</string>
							</dict>
						</dict>
						<key>end</key>
						<string>(?&lt;=\))|(?=(?&lt;=^|[^\\])\s*(\n))</string>
						<key>match</key>
						<string>\)</string>
						<key>patterns</key>
						<array>
							<dict>
								<key>match</key>
								<string>\)</string>
							</dict>
							<dict>
								<key>include</key>
								<string>#ppline-macro-param-next</string>
							</dict>
							<dict>
								<key>include</key>
								<string>#ppline-macro-param-vararg</string>
							</dict>
							<dict>
								<key>include</key>
								<string>#ppline-macro-param-lex</string>
							</dict>
							<dict>
								<key>include</key>
								<string>#ppline-macro-param-lex-invalid</string>
							</dict>
						</array>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-macro-param-vararg</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-macro-param-lex</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-macro-param-lex-invalid</string>
					</dict>
				</array>
			</dict>
		</dict>
		<key>ppline-macro-head-object</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.define.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>entity.name.constant.preprocessor.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?&lt;!##)(?&lt;=#)(\s*define)\s+([A-Za-z_]\w*+)(?!\()[\s&amp;&amp;[^\n]]*</string>
				</dict>
			</array>
		</dict>
		<key>ppline-macro-operator</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*(##)</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>string.macro.stringify.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*(#)\s*([A-Za-z_]\w*+)</string>
				</dict>
			</array>
		</dict>
		<key>ppline-macro-param-lex</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>\s*</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>\s*//</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.comment.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=^|[^\\])\s*(?=\n)$</string>
					<key>name</key>
					<string>invalid.illegal.unexpected-end-of-line.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#lex-continuation</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-preprocessor</string>
				</dict>
			</array>
		</dict>
		<key>ppline-macro-param-lex-invalid</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(?x)
  (?: (?! (?:\s|/\*.*?\*/)*+
          (?: \) | (?&gt;(?:\\\s*)?$\n?) | /[/*] ) )
      .) # no star unlike its friends in arg/vararg</string>
					<key>name</key>
					<string>invalid.illegal.unexpected-character.c</string>
				</dict>
			</array>
		</dict>
		<key>ppline-macro-param-next</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>(,)</string>
				<key>beginCaptures</key>
				<dict>
					<key>1</key>
					<dict>
						<key>name</key>
						<string>punctuation.separator.parameter.c</string>
					</dict>
				</dict>
				<key>end</key>
				<string>\b([A-Za-z_]\w*+)\b|(?=\.\.\.)|(\))|(?=(?&lt;=^|[^\\])\s*(\n))</string>
				<key>endCaptures</key>
				<dict>
					<key>1</key>
					<dict>
						<key>name</key>
						<string>variable.parameter.c</string>
					</dict>
					<key>2</key>
					<dict>
						<key>name</key>
						<string>invalid.illegal.unexpected-closing-paren.c</string>
					</dict>
				</dict>
				<key>patterns</key>
				<array>
					<dict>
						<key>include</key>
						<string>#ppline-macro-param-lex</string>
					</dict>
					<dict>
						<key>begin</key>
						<string>(?x)
  (?: (?! (?:\s|/\*.*?\*/)*+
        (?: \b([A-Za-z_]\w*+)\b | \.\.\. | \) | (?&gt;(?:\\\s*)?$\n?) | /[/*] ) )
      .)*</string>
						<key>name</key>
						<string>invalid.illegal.unexpected-character.c</string>
					</dict>
				</array>
			</dict>
		</dict>
		<key>ppline-macro-param-vararg</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>(\.\.\.)</string>
				<key>beginCaptures</key>
				<dict>
					<key>1</key>
					<dict>
						<key>name</key>
						<string>punctuation.definition.ellipsis.c</string>
					</dict>
				</dict>
				<key>end</key>
				<string>(\))|(?=(?&lt;=^|[^\\])\s*(\n))</string>
				<key>patterns</key>
				<array>
					<dict>
						<key>include</key>
						<string>#ppline-macro-param-lex</string>
					</dict>
					<dict>
						<key>match</key>
						<string>(?x)
  (?: (?! (?:\s|/\*.*?\*/)*+
        (?: \) | (?&gt;(?:\\\s*)?$\n?) | /[/*] ) )
      .)*</string>
						<key>name</key>
						<string>invalid.illegal.unexpected-character.c</string>
					</dict>
				</array>
			</dict>
		</dict>
		<key>ppline-plusplusc</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>^\s*(#)\s*(namespace|operator|accessor)\b</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.++c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
					<key>name</key>
					<string>meta.preprocessor.directive.++c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#lex-core</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#function</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#support</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#block</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#parens</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>ppline-pragma-mark</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(^\s*(#)\s*(pragma\s+mark)\b)[\s&amp;&amp;[^\n]]*</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.pragma.c</string>
						</dict>
					</dict>
					<key>contentName</key>
					<string>meta.toc-list.pragma-mark.c</string>
					<key>end</key>
					<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
					<key>name</key>
					<string>meta.preprocessor.directive.pragma-mark.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#lex-preprocessor</string>
						</dict>
						<dict>
							<key>match</key>
							<string>.</string>
							<key>name</key>
							<string>string.other.pragma-mark.c</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>ppline-undef</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>(^\s*(#)\s*(undef))\s+([A-Za-z_]\w*+)</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>keyword.other.preprocessor.c</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>variable.other.constant.undef.c</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
					<key>name</key>
					<string>meta.preprocessor.undef.c</string>
				</dict>
			</array>
		</dict>
		<key>preprocessor</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>(?=^\s*(#))</string>
				<key>end</key>
				<string>(?!^\s*(#))</string>
				<key>patterns</key>
				<array>
					<dict>
						<key>include</key>
						<string>#preprocessor-disabled</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-directive-invalid-usage</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-macro</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-undef</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-pragma-mark</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-include</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-plusplusc</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-directive</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-directive-obsolete</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-invalid</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#ppline-any</string>
					</dict>
				</array>
			</dict>
		</dict>
		<key>preprocessor-disabled</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>^\s*(#)(?=\s*(if)\b(?=(?:\s|/\*.*?\*/)*+(0[xX])?0++\b(?:\s|/\*.*?\*/)*+(//.*)?\\?$))</string>
				<key>beginCaptures</key>
				<dict>
					<key>0</key>
					<dict>
						<key>name</key>
						<string>meta.preprocessor.directive.c keyword.other.preprocessor.c</string>
					</dict>
				</dict>
				<key>end</key>
				<string>(?=^\s*(#)\s*(endif|else|elif)\b)</string>
				<key>patterns</key>
				<array>
					<dict>
						<key>begin</key>
						<string>^</string>
						<key>end</key>
						<string>$\n?</string>
						<key>name</key>
						<string>comment.other.preprocessor-disabled.c</string>
						<key>patterns</key>
						<array>
							<dict>
								<key>include</key>
								<string>#preprocessor-disabled-conditional</string>
							</dict>
							<dict>
								<key>include</key>
								<string>#preprocessor-disabled-directive</string>
							</dict>
						</array>
					</dict>
					<dict>
						<key>begin</key>
						<string>(?&lt;!##)(?&lt;=#)\s*(if)\b(?=(?:\s|/\*.*?\*/)*+(0[xX])?0++\b(?:\s|/\*.*?\*/)*+(//.*)?\\?$)</string>
						<key>beginCaptures</key>
						<dict>
							<key>1</key>
							<dict>
								<key>name</key>
								<string>keyword.other.preprocessor.define.c</string>
							</dict>
						</dict>
						<key>end</key>
						<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
						<key>name</key>
						<string>meta.preprocessor.directive.c</string>
						<key>patterns</key>
						<array>
							<dict>
								<key>include</key>
								<string>#lex-core</string>
							</dict>
						</array>
					</dict>
				</array>
			</dict>
		</dict>
		<key>preprocessor-disabled-conditional</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>^\s*(#)\s*if(n?def)?\b</string>
				<key>end</key>
				<string>^\s*(#)\s*endif\b.*$\n?</string>
				<key>patterns</key>
				<array>
					<dict>
						<key>include</key>
						<string>#preprocessor-disabled-conditional</string>
					</dict>
					<dict>
						<key>include</key>
						<string>#preprocessor-disabled-directive</string>
					</dict>
				</array>
			</dict>
		</dict>
		<key>preprocessor-disabled-directive</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>^\s*(#)</string>
				<key>end</key>
				<string>(?&lt;=$\n)(?&lt;!\\$\n)</string>
			</dict>
		</dict>
		<key>regex-character-class</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>\\[wWsSdDtrnvf]|\.</string>
					<key>name</key>
					<string>constant.other.character-class.regexp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})</string>
					<key>name</key>
					<string>constant.character.numeric.regexp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\\c[A-Z]</string>
					<key>name</key>
					<string>constant.character.control.regexp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\\.</string>
					<key>name</key>
					<string>constant.character.escape.backslash.regexp</string>
				</dict>
			</array>
		</dict>
		<key>regexp</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>begin</key>
					<string>\\[1-9]\d*|\\k&lt;([a-zA-Z_$][\w$]*)&gt;</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>keyword.other.back-reference.regexp</string>
						</dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>variable.other.regexp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\\[bB]|\^|\$</string>
					<key>name</key>
					<string>keyword.control.anchor.regexp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>[?+*]|\{(\d+,\d+|\d+,|,\d+|\d+)\}\??</string>
					<key>name</key>
					<string>keyword.operator.quantifier.regexp</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\|</string>
					<key>name</key>
					<string>keyword.operator.or.regexp</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>(\()((\?=)|(\?!)|(\?&lt;=)|(\?&lt;!))</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.group.regexp</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.group.assertion.regexp</string>
						</dict>
						<key>3</key>
						<dict>
							<key>name</key>
							<string>meta.assertion.look-ahead.regexp</string>
						</dict>
						<key>4</key>
						<dict>
							<key>name</key>
							<string>meta.assertion.negative-look-ahead.regexp</string>
						</dict>
						<key>5</key>
						<dict>
							<key>name</key>
							<string>meta.assertion.look-behind.regexp</string>
						</dict>
						<key>6</key>
						<dict>
							<key>name</key>
							<string>meta.assertion.negative-look-behind.regexp</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\))</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.group.regexp</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.group.assertion.regexp</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#regexp</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>begin</key>
					<string>\((?:(\?:)|(?:\?&lt;([a-zA-Z_$][\w$]*)&gt;))?</string>
					<key>beginCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.group.regexp</string>
						</dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.group.no-capture.regexp</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>variable.other.regexp</string>
						</dict>
					</dict>
					<key>end</key>
					<string>\)</string>
					<key>endCaptures</key>
					<dict>
						<key>0</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.group.regexp</string>
						</dict>
					</dict>
					<key>name</key>
					<string>meta.group.regexp</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>include</key>
							<string>#regexp</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.character-class.regexp</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.operator.negation.regexp</string>
						</dict>
					</dict>
					<key>end</key>
					<string>(\])</string>
					<key>endCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>punctuation.definition.character-class.regexp</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(\[)(\^)?</string>
					<key>name</key>
					<string>constant.other.character-class.set.regexp</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>captures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>constant.character.numeric.regexp</string>
								</dict>
								<key>2</key>
								<dict>
									<key>name</key>
									<string>constant.character.control.regexp</string>
								</dict>
								<key>3</key>
								<dict>
									<key>name</key>
									<string>constant.character.escape.backslash.regexp</string>
								</dict>
								<key>4</key>
								<dict>
									<key>name</key>
									<string>constant.character.numeric.regexp</string>
								</dict>
								<key>5</key>
								<dict>
									<key>name</key>
									<string>constant.character.control.regexp</string>
								</dict>
								<key>6</key>
								<dict>
									<key>name</key>
									<string>constant.character.escape.backslash.regexp</string>
								</dict>
							</dict>
							<key>match</key>
							<string>(?:.|(\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\c[A-Z])|(\\.))\-(?:[^\]\\]|(\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\c[A-Z])|(\\.))</string>
							<key>name</key>
							<string>constant.other.character-class.range.regexp</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#regex-character-class</string>
						</dict>
					</array>
				</dict>
				<dict>
					<key>include</key>
					<string>#regex-character-class</string>
				</dict>
			</array>
		</dict>
		<key>string-escape-sequence</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>\\(\\|[abefnprtv'"?]|[0-3]\d{,2}|[4-7]\d?|x[a-fA-F0-9]{,2}|u[a-fA-F0-9]{,4}|U[a-fA-F0-9]{,8})</string>
					<key>name</key>
					<string>constant.character.escape.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>\\.</string>
					<key>name</key>
					<string>invalid.illegal.unknown-escape.c</string>
				</dict>
			</array>
		</dict>
		<key>string-format-specifier</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(?x)%
  (\d+\$)?                             # field (argument #)
  [#0\- +']*                           # flags
  [,;:_]?                              # separator character (AltiVec)
  ((-?\d+)|\*(-?\d+\$)?)?              # minimum field width
  (\.((-?\d+)|\*(-?\d+\$)?)?)?         # precision
  (hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)? # length modifier
  [diouxXDOUeEfFgGaACcSspn%bBqkKm]     # conversion type (the last ones: "bBqkKm" are ++C additions)</string>
					<key>name</key>
					<string>constant.other.placeholder.c</string>
				</dict>
				<dict>
					<key>match</key>
					<string>%</string>
					<key>name</key>
					<string>invalid.illegal.placeholder.c</string>
				</dict>
			</array>
		</dict>
		<key>support</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#support-type</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#support-macro</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#support-function</string>
				</dict>
			</array>
		</dict>
		<key>support-function</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.function.C99.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(hypot(f|l)?|s(scanf|ystem|nprintf|ca(nf|lb(n(f|l)?|ln(f|l)?))|i(n(h(f|l)?|f|l)?|gn(al|bit))|tr(s(tr|pn)|nc(py|at|mp)|c(spn|hr|oll|py|at|mp)|to(imax|d|u(l(l)?|max)|k|f|l(d|l)?)|error|pbrk|ftime|len|rchr|xfrm)|printf|et(jmp|vbuf|locale|buf)|qrt(f|l)?|w(scanf|printf)|rand)|n(e(arbyint(f|l)?|xt(toward(f|l)?|after(f|l)?))|an(f|l)?)|c(s(in(h(f|l)?|f|l)?|qrt(f|l)?)|cos(h(f)?|f|l)?|imag(f|l)?|t(ime|an(h(f|l)?|f|l)?)|o(s(h(f|l)?|f|l)?|nj(f|l)?|pysign(f|l)?)|p(ow(f|l)?|roj(f|l)?)|e(il(f|l)?|xp(f|l)?)|l(o(ck|g(f|l)?)|earerr)|a(sin(h(f|l)?|f|l)?|cos(h(f|l)?|f|l)?|tan(h(f|l)?|f|l)?|lloc|rg(f|l)?|bs(f|l)?)|real(f|l)?|brt(f|l)?)|t(ime|o(upper|lower)|an(h(f|l)?|f|l)?|runc(f|l)?|gamma(f|l)?|mp(nam|file))|i(s(space|n(ormal|an)|cntrl|inf|digit|u(nordered|pper)|p(unct|rint)|finite|w(space|c(ntrl|type)|digit|upper|p(unct|rint)|lower|al(num|pha)|graph|xdigit|blank)|l(ower|ess(equal|greater)?)|al(num|pha)|gr(eater(equal)?|aph)|xdigit|blank)|logb(f|l)?|max(div|abs))|di(v|fftime)|_Exit|unget(c|wc)|p(ow(f|l)?|ut(s|c(har)?|wc(har)?)|error|rintf)|e(rf(c(f|l)?|f|l)?|x(it|p(2(f|l)?|f|l|m1(f|l)?)?))|v(s(scanf|nprintf|canf|printf|w(scanf|printf))|printf|f(scanf|printf|w(scanf|printf))|w(scanf|printf)|a_(start|copy|end|arg))|qsort|f(s(canf|e(tpos|ek))|close|tell|open|dim(f|l)?|p(classify|ut(s|c|w(s|c))|rintf)|e(holdexcept|set(e(nv|xceptflag)|round)|clearexcept|testexcept|of|updateenv|r(aiseexcept|ror)|get(e(nv|xceptflag)|round))|flush|w(scanf|ide|printf|rite)|loor(f|l)?|abs(f|l)?|get(s|c|pos|w(s|c))|re(open|e|ad|xp(f|l)?)|m(in(f|l)?|od(f|l)?|a(f|l|x(f|l)?)?))|l(d(iv|exp(f|l)?)|o(ngjmp|cal(time|econv)|g(1(p(f|l)?|0(f|l)?)|2(f|l)?|f|l|b(f|l)?)?)|abs|l(div|abs|r(int(f|l)?|ound(f|l)?))|r(int(f|l)?|ound(f|l)?)|gamma(f|l)?)|w(scanf|c(s(s(tr|pn)|nc(py|at|mp)|c(spn|hr|oll|py|at|mp)|to(imax|d|u(l(l)?|max)|k|f|l(d|l)?|mbs)|pbrk|ftime|len|r(chr|tombs)|xfrm)|to(b|mb)|rtomb)|printf|mem(set|c(hr|py|mp)|move))|a(s(sert|ctime|in(h(f|l)?|f|l)?)|cos(h(f|l)?|f|l)?|t(o(i|f|l(l)?)|exit|an(h(f|l)?|2(f|l)?|f|l)?)|b(s|ort))|g(et(s|c(har)?|env|wc(har)?)|mtime)|r(int(f|l)?|ound(f|l)?|e(name|alloc|wind|m(ove|quo(f|l)?|ainder(f|l)?))|a(nd|ise))|b(search|towc)|m(odf(f|l)?|em(set|c(hr|py|mp)|move)|ktime|alloc|b(s(init|towcs|rtowcs)|towc|len|r(towc|len))))\s*\(\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.function.cpython.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?x)
  \s*\b
  (   Py_REFCNT | Py_TYPE | Py_SIZE
    | Py_X?(?:INC|DEC)REF | Py_CLEAR
    | _?Py(?:Object|Type|HeapType|Dict|Set|List|Tuple|Long|Exception|Err)_\w++ )
  \b</string>
				</dict>
			</array>
		</dict>
		<key>support-macro</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.function.constant.intrinsic.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(__builtin_\w++)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.function.constant.linux-kernel.macro.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?x)
  \s*\b
  (   (?:__)?(?:DECL(?:ARE)?|DEF(?:INE)?)_[A-Z0-9_]+
    | (?:__)?[A-Z_][A-Z0-9_]*_(?:DECL(?:ARE)?|DEF(?:INE)?)
    | EXPORT(?:_UNUSED)?(?:_PER_CPU)?_SYMBOL(?:_GPL(?:_FUTURE)?)?
    | MODULE_(?:INFO|ALIAS|LICENSE|AUTHOR|DESCRIPTION|DEVICE_TABLE|VERSION|FIRMWARE)
    | (?:__)?MODULE_PARM_(?:TYPE|DESC)
    | module_param(?:(?:_array)?(?:_named)?|_call)
    | (?:module|core|postcore|arch|subsys|fs|device|late)_param_cb
    | [HL]?LIST_HEAD
    | (?:_|__BIN|BIN|BUS|DRIVER|CLASS|DEVICE)_ATTR(?:_R[OW])? )
  \b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.function.constant.windows-sal2.annotation.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?x)
  \s*\b
  (   _(?:IRQL|Kernel)_\w+_
    | _Interlocked_operand_
    | _Dispatch_type_
    | _Flt_CompletionContext_Outptr_ )
  \b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.function.constant.cpython.macro.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>keyword.control.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>(?x)
  \s*\b
  (   PyAPI_(?:FUNC|DATA)
    | PyMODINIT_FUNC
    | Py_LOCAL(?:_INLINE)?
    | PyDoc_(?:STR(?:VAR)?|VAR)
    | PyObject(?:_VAR)?_HEAD
    | _PyObject_HEAD_EXTRA
    | PyException_HEAD
    | Py(?:Var)?Object_HEAD_INIT
    | PyModuleDef_HEAD_INIT
    | Py_(RETURN)_(?:FALSE|TRUE|NONE|NOTIMPLEMENTED|NAN|INF) )
  \b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.function.constant.cpython.macro.c</string>
						</dict>
						<key>2</key>
						<dict>
							<key>name</key>
							<string>string.support.cpython.identifier.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(_Py_IDENTIFIER)\b\s*\(\s*([A-Za-z_]\w*+)\s*\)</string>
				</dict>
				<dict>
					<key>begin</key>
					<string>\s*\b((?:CONFIG|HAVE)_[A-Z0-9_]++)\b</string>
					<key>beginCaptures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.constant.config.c</string>
						</dict>
					</dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>string.support.cpython.identifier.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\bPyId_([A-Za-z_]\w*+)\b</string>
				</dict>
			</array>
		</dict>
		<key>support-type</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.type.stdlib.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(u_char|u_short|u_int|u_long|ushort|uint|(?:u_quad|quad|qaddr|caddr|daddr|dev|fixpt|blkcnt|blksize|gid|in_addr|in_port|ino|key|mode|nlink|id|pid|off|segsz|swblk|uid|id|clock|size|ssize|time|useconds|suseconds|siginfo)_t)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.type.stdint.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(u?int(?:(?:_least|_fast)?(?:8|16|32|64)_t|ptr_t|max_t))\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.type.stdarg.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(va_list)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.type.libccc.++c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b([tseuf]_\w+)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.type.pthread.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(pthread_(?:t|attr_t|once_t|key_t|(?:cond|mutex|rwlock)(?:attr)?_t))\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.type.libuv.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b(uv_\w+_t)\b</string>
				</dict>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>support.type.SDL2.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\s*\b((SDL_([A-Z][a-z]+)\w+(?!\()))\b</string>
				</dict>
			</array>
		</dict>
		<key>translation_unit</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>include</key>
					<string>#block-special</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#typedef</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex-type</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#lex</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#function</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#support</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#block</string>
				</dict>
				<dict>
					<key>include</key>
					<string>#parens</string>
				</dict>
			</array>
		</dict>
		<key>type-declaration</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>end</key>
					<string>(?&lt;=;)</string>
					<key>match</key>
					<string>(?x)
  (?&lt;=  \A enum | \A (?:class|union) | \A struct |
        \W enum | \W (?:class|union) | \W struct )
  \b
  (?= (?:\s|/\*.*?\*/)*+
      ([A-Za-z_]\w*+)
      (?:\s|/\*.*?\*/)*+;
  )</string>
					<key>name</key>
					<string>meta.compound.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>\s*\b([A-Za-z_]\w*+)\b</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>entity.name.type.declaration.c</string>
								</dict>
							</dict>
							<key>include</key>
							<string>#lex</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>type-definition</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>end</key>
					<string>(?x)
  (?: (?!\s*(?:[A-Za-z_({]|/[/*]|$))
    | (?= \s*\b(?: [A-Za-z_]\w*+ ) (?= \s* [\[;] ) )
    | (?&lt;!\})(?=
          # Prefer function definition over an attribute defined
          # through a macro, unless a block has been seen. That is:
          #   struct __packed __aligned(16) foo {...}; - function __aligned
          #   struct foo {...} __packed __aligned(16); - structure foo
          (?! \s* \b__attribute__\b )

          (?: ^
            | (?&lt;! (?&lt;!\w) new
                  | (?&lt;!\w) (?:else|enum)
                  | (?&lt;!\w) (?:class|union)
                  | (?&lt;!\w) (?:struct|return|sizeof|typeof)
                  | (?&lt;!\w) __sizeof|__typeof
                  | (?&lt;!\w) __sizeof__|__typeof__
              )
              (?&lt;= \w ) \s

            | #  or type modifier / closing bracket before name
              (?&lt;= [^&amp;]&amp; | [*&gt;)}\]] ) ) \s*

          (?: [A-Za-z_]\w*+ | ::[^:] | \. )++
          (?: (?&lt;= ^ operator | \W operator )  # C++ operator?
              (?: [-*&amp;&lt;&gt;=+!]+ | \(\) | \[\] ) )?
          (?:\s|/\*.*?\*/)*+ \( ) )</string>
					<key>match</key>
					<string>(?x)
  (?&lt;=  \A enum | \A (?:class|union) | \A struct |
        \W enum | \W (?:class|union) | \W struct )
  \b
  # Negation of zero-length parts of the end pattern
  # to prevent entering the rule if it's gonna exit immediately.
  # (workaround ST2 bugs, see issue #10)
  (?=\s*(?:[A-Za-z_({]|/[/*]|$))
  (?! \s*\b(?: [A-Za-z_]\w*+ ) (?= \s* [\[;] ) )</string>
					<key>name</key>
					<string>meta.compound.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>begin</key>
							<string>(?&lt;=\})</string>
							<key>end</key>
							<string>(?!\s*(?:[A-Za-z_({]|/[/*]|$))</string>
							<key>patterns</key>
							<array>
								<dict>
									<key>include</key>
									<string>#lex</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#block</string>
								</dict>
								<dict>
									<key>include</key>
									<string>#parens</string>
								</dict>
							</array>
						</dict>
						<dict>
							<key>include</key>
							<string>#lex</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#block</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#parens</string>
						</dict>
						<dict>
							<key>captures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>entity.name.type.class.c entity.name.class.c</string>
								</dict>
							</dict>
							<key>match</key>
							<string>\b([A-Za-z_]\w*+)(?=(?:\s|/\*.*?\*/)*+(?:\{|(//.*)?\\?$))</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>typedef</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>match</key>
					<string>(?x) (?&lt;= \A typedef | \W typedef ) \b</string>
					<key>name</key>
					<string>meta.typedef.c</string>
					<key>patterns</key>
					<array>
						<dict>
							<key>match</key>
							<string>(;)</string>
							<key>name</key>
							<string>punctuation..terminator.c</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#lex</string>
						</dict>
						<dict>
							<key>include</key>
							<string>#type-definition</string>
						</dict>
						<dict>
							<key>begin</key>
							<string>\s*\b([A-Za-z_]\w*+)(?=\s*[\[;])</string>
							<key>beginCaptures</key>
							<dict>
								<key>1</key>
								<dict>
									<key>name</key>
									<string>entity.name.type.typedef.c</string>
								</dict>
							</dict>
							<key>include</key>
							<string>#block</string>
						</dict>
					</array>
				</dict>
			</array>
		</dict>
		<key>variable</key>
		<dict>
			<key>patterns</key>
			<array>
				<dict>
					<key>captures</key>
					<dict>
						<key>1</key>
						<dict>
							<key>name</key>
							<string>variable.other.c</string>
						</dict>
					</dict>
					<key>match</key>
					<string>\b([A-Za-z_]\w*+)\b</string>
				</dict>
			</array>
		</dict>
		<key>variable-declaration</key>
		<dict>
			<key>patterns</key>
			<dict>
				<key>begin</key>
				<string>(?x)
  (?: (?&lt;! (?&lt;!\w) new
        | (?&lt;!\w) (?:else|enum)
        | (?&lt;!\w) (?:class|union)
        | (?&lt;!\w) (?:struct|return|sizeof|typeof)
        | (?&lt;!\w) __typeof | (?&lt;!\w) __typeof__
      )
      (?&lt;= \w\b)
    | #  or type modifier / closing bracket before name
      (?&lt;= [*&gt;)}\]] )
  )
  \s*+
  (   (?: [A-Za-z_]\w*+ | ::[^:] )++ )
  (?=
    (?:\s|/\*.*?\*/)*+
    [=;,\)\[]
  )</string>
				<key>captures</key>
				<dict>
					<key>1</key>
					<dict>
						<key>name</key>
						<string>entity.name.variable.declaration.c</string>
					</dict>
				</dict>
			</dict>
		</dict>
	</dict>
	<key>scopeName</key>
	<string>source.c</string>
</dict>
</plist>
