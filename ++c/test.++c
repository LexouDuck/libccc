
#namespace NameSpace.SubSpace
#function int	FunctionName(int arg)	{ DoSomething(); return (var); }
#operator	$	(int a, int b) = int	{ return (DoOperation(a, b)); }
#accessor (int var)[int index] = int	{ return (GetFunction(var, index)); }
#reflect // type reflection - type stringization , enum stringization, etc ?
#replace("old", "new")
#header(__HEADER_H)
#incbin(myvar, "filepath")
#alias(token)		// shorter way of writing __attribute__((alias, ...))
#align(4)			// shorter way of writing __attribute__((align, ...))
#format(func, 1, 2)	// shorter way of writing __attribute__((format, ...))
#malloc				// shorter way of writing __attribute__((malloc, ...))
#delete				// shorter way of writing __attribute__((delete, ...))
#inline				// shorter way of writing __attribute__((always_inline, ...)) inline
#pure				// shorter way of writing __attribute__((pure, ...))
#packed				// shorter way of writing __attribute__((packed, ...))


value = *pointer; // pure C
value = $pointer; // ++C


address = &value; // pure C
address = @value; // ++C


value = 255;	// pure C
value := 255;	// ++C


value = 0644; // pure C
value = 0o644; // ++C


char*	strings[9];	// pure C
char*[9] strings;	// ++C


void	(*f)(int, char*);	// pure C
(int, char*) => void	f;	// ++C


char const* regex1 = r"\b(My_\w*)\b"g;
char const* regex2 = r"(?x) ( [^)] __damn__ )"i;
char const* regex3 = r"[a-zA-Z_]\w*"sg;


// in .h header file
#namespace String
char*	Duplicate(char* str);
#namespace // using the namespace instruction with nothing after it ends the namespace section

// in .c source file
char*	String.Duplicate(char* str)
{
	return (Memory.Duplicate(String.Length(str) + 1));
}
char* str = String.Duplicate("foo");


// in .h header file
#namespace Compression.RLE
t_u8*	Compress(t_u8* data, size_t length);
t_u8*	Decompress(t_u8* data);

#namespace Compression.LZ77	// a new `#namespace` directive replaces the previous one, similar to `.section` in ASM
t_u8*	Compress(t_u8* data, size_t length);
t_u8*	Decompress(t_u8* data);

// in .c source file
t_u8* decompressed_data_rle = Compression.RLE.Decompress(file);
t_u8* decompressed_data_lz77 = Compression.LZ77.Decompress(file);


void	WaitAndRunCallback(void (*callback)(void));

int	main()
{
	WaitAndRunCallback(
		#function void HelloWorld(void)
		{
			printf("Hello World!\n");
		}
	);
}


// NB: when transpiled to C, the 'HelloWorld' local function will be in global scope, named:
void	WaitAndRunCallback(void (*callback)(void));

static void	main_HelloWorld(void)
{
	printf("Hello World!\n");
}
int	main()
{
	WaitAndRunCallback(
		&main_HelloWorld
	);
}


// integer power operator
#operator ** (int left, int right) = int
{
	return (Math<int>.Power(left, right));
}
// usage example:
printf("%d", 2 ** 15);


// NULL check and return operator
#operator ?? (void const* left, void const* right) = void const*
{
	return (left == NULL ? right : left);
}
// usage example:
char* new_str = str ?? "str is NULL";


// fixed-point math
#operator	+ (t_fixed a, t_fixed b) = t_fixed	{ return (Fixed.Add(a, b)); }
#operator	- (t_fixed a, t_fixed b) = t_fixed	{ return (Fixed.Sub(a, b)); }
#operator	* (t_fixed a, t_fixed b) = t_fixed	{ return (Fixed.Mul(a, b)); }
#operator	/ (t_fixed a, t_fixed b) = t_fixed	{ return (Fixed.Div(a, b)); }


// string concatenation operators
#operator  +	(char const* left, char const* right) = char*	{ return (String.Join(left, right)); }
#operator  :+	(char*       left, char const* right) = char*	{ return (String.Append(left, right)); }
#operator  +:	(char const* left, char*       right) = char*	{ return (String.Prepend(left, right)); }
#operator  :+:	(char*       left, char*       right) = char*	{ return (String.Merge(left, right)); }

// usage example:
char* new_str = "Concatenated: " + str;


// unary complex number conjugate operator
typedef struct	s_complex_
{
	float re;
	float im;
}				s_complex;
#operator ! (s_complex right) = s_complex
{
	return (Complex.Conjugate(right));
}
// usage example:
s_complex z = { 1.5, 2.2 };
s_complex conjug = !z;


// bool exclusive OR (XOR) operator
#operator ^^ (bool left, bool right) = bool
{
	return ((left ? TRUE : FALSE) ^ (right ? TRUE : FALSE));
}
// usage example:
if (i < 3 ^^ x >= 4) { /* do stuff */}


// 3D vector subtraction operator
#operator - (s_vector3d left, s_vector3d right) = s_vector3d
{
//	return (Vector3D.Add(left, right));
	return ((s_vector3d)
	{
		.x = left.x - right.x,
		.y = left.y - right.y,
		.z = left.z - right.z,
	});
}
// usage example:
s_vector3d u = (s_vector3d){ 1, 2, 3 };
s_vector3d v = (s_vector3d){ 4, 5, 6 };
s_vector3d diff = (u - v);


// example color type
typedef	uint32_t	t_argb32;
// example palette color array struct
typedef struct	s_palette_
{
	size_t		color_count;
	t_argb32*	colors;
}				s_palette;
// declare an accessor to get colors from the palette
#accessor (s_palette palette)[int index] = t_argb32
{
	return (palette.colors[index]);
}
// usage example:
t_argb32 color = palette[3];


// example 32-bit color bitmap array
typedef struct	s_bitmap_
{
	t_argb32*	pixels;
	int			width;
	int			height;
}				s_bitmap;
// declare an accessor to get pixels from their coordinates
#accessor (s_bitmap bitmap)[int x, int y] = t_argb32
{
	return (bitmap.pixels[y * bitmap.width + x]);
}
// usage example:
for (int x = 0; x < bitmap->width; ++x)
for (int y = 0; y < bitmap->height; ++y)
{
	t_argb32 color = bitmap[x, y];
}


typedef struct	s_keyval_
{
	char*		key;
	char*		type;
	void*		value;
}				s_keyval;
typedef struct	s_dict_
{
	t_size		count;
	s_keyval*	items;
}				s_dict;

#namespace Dict
s_dict	New(int items, s_keyval ...)
{
	return ((s_dict)
	{
		.count = items,
		Array<s_keyval>.New(items, va_list),
	});
}
// declare an accessor to get dictionary values from their key names
#accessor (s_dict dict)[char const* key] = void*
{
	return (Dict.Get(dict, key));
}

// usage example:
s_dict dict = Dict.New(2,
	(s_keyval){ .key="foo", .value="FOO" },
	(s_keyval){ .key="bar", .value="BAR" },
);
char* bar = (char*)dict["bar"];


// parse utf8 char smartly in a string
typedef wchar_t	t_utf8;
t_utf8	String_Get_UTF8(t_utf8* str, size_t index)
{
	char* str = (char*)utf8;
	t_utf8 result = str[index];
	if (str[++index] && (result & 0x000080))	result |= (str[index] << 8);
	if (str[++index] && (result & 0x008000))	result |= (str[index] << 16);
	if (str[++index] && (result & 0x800000))	result |= (str[index] << 24);
	return (result);
}
#accessor 	(t_utf8* str)[size_t index] = t_utf8	
{
	return (String_Get_UTF8(str, index));
}
// usage example:
char* str = "char Ã±";
t_utf8 utf8_char = (t_utf8*)str[5];


// a generic typed namespace can indicate a default type (which will be used if no <T> is written)
#namespace List<TYPE=void*> // by default, 'void*' type will be used
// Functions in this namespace cannot really use the generic type directly, they must treat it as opaque

typedef struct	s_list_<TYPE>
{
	s_list*		next;
	size_t		item_size;
	TYPE		item;
}				s_list<TYPE>;
// usage example:
s_list<char*> const*	string_list;


// a generic typed namespace can have a restricted set of types
// Functions using this namespace can have different implementations for each child type, such that they can use them directly
#namespace Math<TYPE=float|double|fixed|int>
TYPE	Cos(TYPE x);

// usage example:
float cosine_float = Math<float>.Cos(value);	// specific implementation for 32-bit floating-point type cos()
double cosine_f64 = Math<double>.Cos(value);	// specific implementation for 64-bit floating-point type cos()
fixed cosine_fixed = Math<fixed>.Cos(value);	// specific implementation for fixed-point type cos()


// in .h header file
#namespace List<TYPE=void*> // by default, 'void*' type will be used

s_list<TYPE>	New(size_t length, TYPE ...);
void			Append(s_list<TYPE> list, s_list<TYPE> element);
s_list<TYPE>	Filter(s_list<TYPE> list, bool (*filter)(s_list<TYPE> element));

// usage example:
// in .c source file
s_list<char*> list = List<char*>.New(3, "foo", "bar", "baz");


// usage example:
void	KeepOnlyEvenNumbers(s_list<int> integers)
{
	s_list<int> only_even = List<int>.Filter(integers,
		#function bool	filter(s_list<int> element)
		{
			return (element.item % 2 == 0);
		}
	);
}
// NB: when transpiled to C, the 'filter' local function will be in global scope, named:
static bool	KeepOnlyEvenNumbers_filter(s_list<int> element)
{
	return (element.item % 2 == 0);
}


// list concatenation operator
#namespace List<TYPE=void*>
#operator + (s_list<TYPE>* left, s_list<TYPE>* right) = s_list<TYPE>
{
	return (List<TYPE>.Join(left, right));
}

// usage example:
s_list<char*> list = List<char*>.New(2, "foo", "bar");
s_list<char*> list = List<char*>.New(2, "bar", "baz");
s_list<char*> concat = list1 + list2; // type inferrence for the operator


// list index get
#namespace List<TYPE=void*>
#accessor (s_list<TYPE>* list)[size_t index] = TYPE
{
	return (List<TYPE>.Get(list, index));
}

// usage example:
s_list<char*> list = List<char*>.New(3, "foo", "bar", "baz");
char* str = list[2]; // type inferrence for the accessor


#namespace KeyVal<TYPE>

typedef struct	keyval_<TYPE>
{
	char*	key;
	char*	type;
	TYPE	value;
}				s_keyval<TYPE>;

s_keyval<TYPE>	New(char* key, TYPE value);



#namespace Object<TYPE=void*>

typedef s_keyval<void*>*	t_object;

t_object*	New(size_t items, s_keyval ...);

#accessor (t_object* obj)[char const* key] = TYPE
{
	return (Object<TYPE>.Get(obj, key));
}



t_object* obj = Object.New(3,
	KeyVal<int>.New("index", 1), // = &(s_keyval<int>){ .key="index", .type="int", .value=1 }
	KeyVal<char*>.New("value", "foo"),
	KeyVal<t_object>.New("sub", Object.New(2,
		KeyVal<float>.New("float", 1.5),
		KeyVal<char*>.New("str", "hello")),
);
printf("%s\n", obj<object*>["sub"]<char*>["str"]); // type inferrence cannot be done here


#incbin myfile	"./path/to/file.dat"


void		MyFunction(void);
#replace f	MyFunction
int main()
{
	f();
}


void		MyFunction(void);
int main()
{
	MyFunction();
}


// ++C code
#header(__HEADER_H)
// this is a simple test header
void HelloWorld(void);
// ...


// C code
#ifndef __HEADER_H
#define __HEADER_H

#ifdef __cplusplus
extern "C" /{
#endif

// this is a simple test header
void HelloWorld(void);
// ...

#ifdef __cplusplus
} // extern c
#endif

#endif


// ++C code
#header
// ...

// transpiled output C code
#ifndef __SRC_UTILS_HEADER_H
#define __SRC_UTILS_HEADER_H
// ...
#endif


void			MyFunction(void);
#alias	func	MyFunction


// transpiles to:
void	MyFunction(void);
#ifdef __GNUC__
void	func(void) __attribute__((weak, alias("MyFunction")));
#else
#define func	MyFunction
#endif


void		MyFunction(void);
#alias	func	// `func` is an alias for `MyFunction`

extern int my_global_var;
#alias	my_gv	// `my_gv` is an alias for `my_global_var`


#packed
typedef struct	s_example_
{
	char a;
	int x;
	bool b;
	int y;
}				s_example;


// transpiles to:
__attribute__((packed))
typedef struct	s_example_
{
	...


#inline
void		MyFunction(void);


// transpiles to:
__attribute__((always_inline)) inline
void*	MyFunction(void);


#pure
char	MyFunction(char c);


// transpiles to:
__attribute__((pure))
char	MyFunction(char c);


#malloc
char*	MyFunction(void);


// transpiles to:
__attribute__((malloc))
char*	MyFunction(void);


#format(printf, 1, 2)
void	MyFunction(char* format, ...);


// transpiles to:
__attribute__((format(printf, 1, 2)))
void	MyFunction(char* format, ...);


void*		->	void$
void const*	->	void@
