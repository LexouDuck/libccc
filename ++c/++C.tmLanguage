{
    "scope": "source.c", 
    "comment": "https://github.com/abusalimov/SublimeCImproved\nhttps://github.com/lexouduck/libccc\n  This is the ++C syntax coloring regex/lex rules, in sublime-syntax format\n  which is derived from CImproved.tmLanguage - the Sublime Text syntax definition plugin package,\n  which is derived from C.tmLanguage - the original TextMate and Sublime Text syntax definition.\n", 
    "contexts": {
        "preprocessor-disabled": [
            {
                "captures": {
                    "0": "meta.preprocessor.directive.c keyword.other.preprocessor.c"
                }, 
                "push": [
                    {
                        "match": "(?=^\\s*(#)\\s*(endif|else|elif)\\b)", 
                        "pop": true
                    }, 
                    {
                        "push": [
                            {
                                "meta_scope": "comment.other.preprocessor-disabled.c"
                            }, 
                            {
                                "include": "preprocessor-disabled-conditional"
                            }, 
                            {
                                "include": "preprocessor-disabled-directive"
                            }, 
                            {
                                "match": "$\\n?", 
                                "pop": true
                            }
                        ], 
                        "match": "^"
                    }, 
                    {
                        "captures": {
                            "1": "keyword.other.preprocessor.define.c"
                        }, 
                        "push": [
                            {
                                "meta_scope": "meta.preprocessor.directive.c"
                            }, 
                            {
                                "include": "lex-core"
                            }, 
                            {
                                "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                                "pop": true
                            }
                        ], 
                        "match": "(?<!##)(?<=#)\\s*(if)\\b(?=(?:\\s|/\\*.*?\\*/)*+(0[xX])?0++\\b(?:\\s|/\\*.*?\\*/)*+(//.*)?\\\\?$)"
                    }
                ], 
                "match": "^\\s*(#)(?=\\s*(if)\\b(?=(?:\\s|/\\*.*?\\*/)*+(0[xX])?0++\\b(?:\\s|/\\*.*?\\*/)*+(//.*)?\\\\?$))"
            }
        ], 
        "ppline-macro-operator": [
            {
                "captures": {
                    "1": "keyword.other.preprocessor.c"
                }, 
                "match": "\\s*(##)"
            }, 
            {
                "captures": {
                    "1": "keyword.other.preprocessor.c", 
                    "2": "string.macro.stringify.c"
                }, 
                "match": "\\s*(#)\\s*([A-Za-z_]\\w*+)"
            }
        ], 
        "lex-literal-regex": [
            {
                "captures": {
                    "1": "punctuation.definition.string.begin.c"
                }, 
                "push": [
                    {
                        "meta_scope": "string.regexp.c"
                    }, 
                    {
                        "captures": {
                            "1": "punctuation.definition.string.end.c", 
                            "2": "keyword.other.c"
                        }, 
                        "match": "(\\\")([gimsuy]*)", 
                        "pop": true
                    }, 
                    {
                        "include": "regexp"
                    }
                ], 
                "match": "(?<!\\+\\+|--|})(?<=[=(:,\\[?+!]|^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case|=>|&&|\\|\\||\\*\\/)\\s*(r\\\")(?![\\/*])(?=(?:[^\\/\\\\\\[\\()]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\]|\\(([^\\)\\\\]|\\\\.)+\\))+\\\"([gimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))"
            }, 
            {
                "captures": {
                    "0": "punctuation.definition.string.begin.c"
                }, 
                "push": [
                    {
                        "meta_scope": "string.regexp.c"
                    }, 
                    {
                        "captures": {
                            "1": "punctuation.definition.string.end.c", 
                            "2": "keyword.other.c"
                        }, 
                        "match": "(\\\")([gimsuy]*)", 
                        "pop": true
                    }, 
                    {
                        "include": "regexp"
                    }
                ], 
                "match": "((?<![_$[:alnum:])\\]]|\\+\\+|--|}|\\*\\/)|((?<=^return|[^\\._$[:alnum:]]return|^case|[^\\._$[:alnum:]]case))\\s*)r\\\"(?![\\/*])(?=(?:[^\\/\\\\\\[]|\\\\.|\\[([^\\]\\\\]|\\\\.)+\\])+\\\"([gimsuy]+|(?![\\/\\*])|(?=\\/\\*))(?!\\s*[a-zA-Z0-9_$]))"
            }
        ], 
        "lex-continuation": [
            {
                "scope": "punctuation.separator.continuation.c", 
                "captures": {
                    "1": "keyword.other.line-continuation.c", 
                    "2": "punctuation.whitespace.newline.c"
                }, 
                "match": "(\\\\)$(\\n?)"
            }, 
            {
                "captures": {
                    "1": "invalid.deprecated.space-after-continuation.c"
                }, 
                "match": "\\\\(\\s+?)(?=\\n)$"
            }
        ], 
        "lex-comment": [
            {
                "captures": {
                    "1": "punctuation.definition.comment.block.documentation.c", 
                    "2": "comment.command"
                }, 
                "push": [
                    {
                        "meta_scope": "comment.block.documentation.c"
                    }, 
                    {
                        "match": "(\\*/)", 
                        "pop": true
                    }, 
                    {
                        "include": "comment-documentation"
                    }
                ], 
                "match": "\\s*(/\\*)([*!])"
            }, 
            {
                "captures": {
                    "1": "punctuation.definition.comment.line.documentation.c", 
                    "2": "comment.command"
                }, 
                "push": [
                    {
                        "meta_scope": "comment.line.documentation.c"
                    }, 
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }, 
                    {
                        "include": "comment-documentation"
                    }
                ], 
                "match": "\\s*(//)([/!]<?)"
            }, 
            {
                "captures": {
                    "1": "punctuation.definition.comment.block.c"
                }, 
                "push": [
                    {
                        "meta_scope": "comment.block.c"
                    }, 
                    {
                        "match": "(\\*/)", 
                        "pop": true
                    }, 
                    {
                        "include": "comment"
                    }
                ], 
                "match": "\\s*(/\\*)"
            }, 
            {
                "captures": {
                    "1": "punctuation.definition.comment.line.c"
                }, 
                "push": [
                    {
                        "meta_scope": "comment.line.++c"
                    }, 
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }, 
                    {
                        "include": "comment"
                    }
                ], 
                "match": "\\s*(//)"
            }, 
            {
                "scope": "invalid.illegal.stray-comment-end.c", 
                "match": "\\*/(?![/*])"
            }
        ], 
        "support-function": [
            {
                "captures": {
                    "1": "support.function.C99.c"
                }, 
                "match": "\\s*\\b(hypot(f|l)?|s(scanf|ystem|nprintf|ca(nf|lb(n(f|l)?|ln(f|l)?))|i(n(h(f|l)?|f|l)?|gn(al|bit))|tr(s(tr|pn)|nc(py|at|mp)|c(spn|hr|oll|py|at|mp)|to(imax|d|u(l(l)?|max)|k|f|l(d|l)?)|error|pbrk|ftime|len|rchr|xfrm)|printf|et(jmp|vbuf|locale|buf)|qrt(f|l)?|w(scanf|printf)|rand)|n(e(arbyint(f|l)?|xt(toward(f|l)?|after(f|l)?))|an(f|l)?)|c(s(in(h(f|l)?|f|l)?|qrt(f|l)?)|cos(h(f)?|f|l)?|imag(f|l)?|t(ime|an(h(f|l)?|f|l)?)|o(s(h(f|l)?|f|l)?|nj(f|l)?|pysign(f|l)?)|p(ow(f|l)?|roj(f|l)?)|e(il(f|l)?|xp(f|l)?)|l(o(ck|g(f|l)?)|earerr)|a(sin(h(f|l)?|f|l)?|cos(h(f|l)?|f|l)?|tan(h(f|l)?|f|l)?|lloc|rg(f|l)?|bs(f|l)?)|real(f|l)?|brt(f|l)?)|t(ime|o(upper|lower)|an(h(f|l)?|f|l)?|runc(f|l)?|gamma(f|l)?|mp(nam|file))|i(s(space|n(ormal|an)|cntrl|inf|digit|u(nordered|pper)|p(unct|rint)|finite|w(space|c(ntrl|type)|digit|upper|p(unct|rint)|lower|al(num|pha)|graph|xdigit|blank)|l(ower|ess(equal|greater)?)|al(num|pha)|gr(eater(equal)?|aph)|xdigit|blank)|logb(f|l)?|max(div|abs))|di(v|fftime)|_Exit|unget(c|wc)|p(ow(f|l)?|ut(s|c(har)?|wc(har)?)|error|rintf)|e(rf(c(f|l)?|f|l)?|x(it|p(2(f|l)?|f|l|m1(f|l)?)?))|v(s(scanf|nprintf|canf|printf|w(scanf|printf))|printf|f(scanf|printf|w(scanf|printf))|w(scanf|printf)|a_(start|copy|end|arg))|qsort|f(s(canf|e(tpos|ek))|close|tell|open|dim(f|l)?|p(classify|ut(s|c|w(s|c))|rintf)|e(holdexcept|set(e(nv|xceptflag)|round)|clearexcept|testexcept|of|updateenv|r(aiseexcept|ror)|get(e(nv|xceptflag)|round))|flush|w(scanf|ide|printf|rite)|loor(f|l)?|abs(f|l)?|get(s|c|pos|w(s|c))|re(open|e|ad|xp(f|l)?)|m(in(f|l)?|od(f|l)?|a(f|l|x(f|l)?)?))|l(d(iv|exp(f|l)?)|o(ngjmp|cal(time|econv)|g(1(p(f|l)?|0(f|l)?)|2(f|l)?|f|l|b(f|l)?)?)|abs|l(div|abs|r(int(f|l)?|ound(f|l)?))|r(int(f|l)?|ound(f|l)?)|gamma(f|l)?)|w(scanf|c(s(s(tr|pn)|nc(py|at|mp)|c(spn|hr|oll|py|at|mp)|to(imax|d|u(l(l)?|max)|k|f|l(d|l)?|mbs)|pbrk|ftime|len|r(chr|tombs)|xfrm)|to(b|mb)|rtomb)|printf|mem(set|c(hr|py|mp)|move))|a(s(sert|ctime|in(h(f|l)?|f|l)?)|cos(h(f|l)?|f|l)?|t(o(i|f|l(l)?)|exit|an(h(f|l)?|2(f|l)?|f|l)?)|b(s|ort))|g(et(s|c(har)?|env|wc(har)?)|mtime)|r(int(f|l)?|ound(f|l)?|e(name|alloc|wind|m(ove|quo(f|l)?|ainder(f|l)?))|a(nd|ise))|b(search|towc)|m(odf(f|l)?|em(set|c(hr|py|mp)|move)|ktime|alloc|b(s(init|towcs|rtowcs)|towc|len|r(towc|len))))\\s*\\(\\b"
            }, 
            {
                "captures": {
                    "1": "support.function.cpython.c"
                }, 
                "match": "(?x)\n  \\s*\\b\n  (   Py_REFCNT | Py_TYPE | Py_SIZE\n    | Py_X?(?:INC|DEC)REF | Py_CLEAR\n    | _?Py(?:Object|Type|HeapType|Dict|Set|List|Tuple|Long|Exception|Err)_\\w++ )\n  \\b"
            }
        ], 
        "main": [
            {
                "include": "translation_unit"
            }
        ], 
        "function-call": [
            {
                "push": [
                    {
                        "meta_scope": "meta.function-call.c"
                    }, 
                    {
                        "include": "lex"
                    }, 
                    {
                        "include": "support-function"
                    }, 
                    {
                        "scope": "variable.function.access.c", 
                        "match": "(?:(?<=\\.)|(?<=->))\\b([A-Za-z_]\\w*+)\\b"
                    }, 
                    {
                        "captures": {
                            "1": "variable.function.c", 
                            "2": "punctuation.accessor.c"
                        }, 
                        "match": "\\b(?:([A-Za-z_]\\w*+)|(::[^:]|\\.|->))++\\b"
                    }, 
                    {
                        "include": "parens-lookahead-end"
                    }, 
                    {
                        "match": "\\)", 
                        "pop": true
                    }
                ], 
                "match": "(?x)\n  \\s*\\b\n  (?= # don't consume string, to recognize support functions\n      (?: [A-Za-z_]\\w*+ | ::[^:] | \\. )++\n      (?: \\s|/\\*.*?\\*/)*+\n      \\(\n  )"
            }
        ], 
        "ppline-undef": [
            {
                "captures": {
                    "1": "keyword.other.preprocessor.c", 
                    "4": "variable.other.constant.undef.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.preprocessor.undef.c"
                    }, 
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }
                ], 
                "match": "(^\\s*(#)\\s*(undef))\\s+([A-Za-z_]\\w*+)"
            }
        ], 
        "ppline-plusplusc": [
            {
                "captures": {
                    "0": "keyword.other.preprocessor.++c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.preprocessor.directive.++c"
                    }, 
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }, 
                    {
                        "include": "lex-core"
                    }, 
                    {
                        "include": "function"
                    }, 
                    {
                        "include": "support"
                    }, 
                    {
                        "include": "block"
                    }, 
                    {
                        "include": "parens"
                    }
                ], 
                "match": "^\\s*(#)\\s*(namespace|operator|accessor)\\b"
            }
        ], 
        "preprocessor-disabled-conditional": [
            {
                "push": [
                    {
                        "include": "preprocessor-disabled-conditional"
                    }, 
                    {
                        "include": "preprocessor-disabled-directive"
                    }, 
                    {
                        "match": "^\\s*(#)\\s*endif\\b.*$\\n?", 
                        "pop": true
                    }
                ], 
                "match": "^\\s*(#)\\s*if(n?def)?\\b"
            }
        ], 
        "ppline-any": [
            {
                "captures": {
                    "0": "keyword.other.preprocessor.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.preprocessor.directive.null-directive.c"
                    }, 
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }, 
                    {
                        "include": "lex-core"
                    }
                ], 
                "match": "^\\s*(#)"
            }
        ], 
        "lex-storage": [
            {
                "captures": {
                    "1": "storage.modifier.c"
                }, 
                "match": "\\s*\\b(auto|extern|static|register|__attribute__|(?:__|(?!\\w+__))(?:const|restrict|volatile|inline)(?:__)?)\\b"
            }, 
            {
                "captures": {
                    "1": "storage.type.c, keyword.declaration.c"
                }, 
                "match": "\\s*\\b(class|struct|union|enum)\\b"
            }, 
            {
                "captures": {
                    "1": "storage.type.c"
                }, 
                "match": "\\s*\\b(bool|_Bool|char|_Complex|double|float|_Imaginary|int|long|short|signed|unsigned|void)\\b"
            }
        ], 
        "ppline-invalid": [
            {
                "captures": {
                    "1": "keyword.other.preprocessor.c", 
                    "2": "invalid.illegal.preprocessor.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.preprocessor.directive.illegal.c"
                    }, 
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }
                ], 
                "match": "^\\s*(#)(?!\\s*(?=/[/*]|(?>\\\\\\s*\\n)|\\n|$))\\s*(\\w*)"
            }
        ], 
        "ppline-macro-param-lex": [
            {
                "match": "\\s*"
            }, 
            {
                "captures": {
                    "0": "punctuation.definition.comment.c"
                }, 
                "push": [
                    {
                        "meta_scope": "invalid.illegal.unexpected-end-of-line.c"
                    }, 
                    {
                        "match": "(?<=^|[^\\\\])\\s*(?=\\n)$", 
                        "pop": true
                    }, 
                    {
                        "include": "lex-continuation"
                    }
                ], 
                "match": "\\s*//"
            }, 
            {
                "include": "lex-preprocessor"
            }
        ], 
        "function-definition": [
            {
                "captures": {
                    "1": "entity.name.function.definition.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.function.definition.c"
                    }, 
                    {
                        "include": "lex"
                    }, 
                    {
                        "include": "parens"
                    }, 
                    {
                        "match": "(\\}|;)", 
                        "pop": true
                    }, 
                    {
                        "include": "block-lookahead-end"
                    }, 
                    {
                        "scope": "storage.modifier.c", 
                        "match": "\\s*\\b(const|override)\\b"
                    }
                ], 
                "match": "(?x)\n  (?: (?<! (?<!\\w) new\n        | (?<!\\w) (?:else|enum)\n        | (?<!\\w) (?:class|union)\n        | (?<!\\w) (?:struct|return|sizeof|typeof)\n        | (?<!\\w) __typeof | (?<!\\w) __typeof__\n      )\n      (?<= \\w\\b)\n    | #  or type modifier / closing bracket before name\n      (?<= [*>)}\\]] )\n  )\n  \\s*+\n  (   (?: [A-Za-z_]\\w*+ | ::[^:] | \\. )++ )\n  (?=\n    (?:\\s|/\\*.*?\\*/)*+\n    \\(\n  )"
            }
        ], 
        "support-macro": [
            {
                "captures": {
                    "1": "support.function.constant.intrinsic.c"
                }, 
                "match": "\\s*\\b(__builtin_\\w++)\\b"
            }, 
            {
                "captures": {
                    "1": "support.function.constant.linux-kernel.macro.c"
                }, 
                "match": "(?x)\n  \\s*\\b\n  (   (?:__)?(?:DECL(?:ARE)?|DEF(?:INE)?)_[A-Z0-9_]+\n    | (?:__)?[A-Z_][A-Z0-9_]*_(?:DECL(?:ARE)?|DEF(?:INE)?)\n    | EXPORT(?:_UNUSED)?(?:_PER_CPU)?_SYMBOL(?:_GPL(?:_FUTURE)?)?\n    | MODULE_(?:INFO|ALIAS|LICENSE|AUTHOR|DESCRIPTION|DEVICE_TABLE|VERSION|FIRMWARE)\n    | (?:__)?MODULE_PARM_(?:TYPE|DESC)\n    | module_param(?:(?:_array)?(?:_named)?|_call)\n    | (?:module|core|postcore|arch|subsys|fs|device|late)_param_cb\n    | [HL]?LIST_HEAD\n    | (?:_|__BIN|BIN|BUS|DRIVER|CLASS|DEVICE)_ATTR(?:_R[OW])? )\n  \\b"
            }, 
            {
                "captures": {
                    "1": "support.function.constant.windows-sal2.annotation.c"
                }, 
                "match": "(?x)\n  \\s*\\b\n  (   _(?:IRQL|Kernel)_\\w+_\n    | _Interlocked_operand_\n    | _Dispatch_type_\n    | _Flt_CompletionContext_Outptr_ )\n  \\b"
            }, 
            {
                "captures": {
                    "1": "support.function.constant.cpython.macro.c", 
                    "2": "keyword.control.c"
                }, 
                "match": "(?x)\n  \\s*\\b\n  (   PyAPI_(?:FUNC|DATA)\n    | PyMODINIT_FUNC\n    | Py_LOCAL(?:_INLINE)?\n    | PyDoc_(?:STR(?:VAR)?|VAR)\n    | PyObject(?:_VAR)?_HEAD\n    | _PyObject_HEAD_EXTRA\n    | PyException_HEAD\n    | Py(?:Var)?Object_HEAD_INIT\n    | PyModuleDef_HEAD_INIT\n    | Py_(RETURN)_(?:FALSE|TRUE|NONE|NOTIMPLEMENTED|NAN|INF) )\n  \\b"
            }, 
            {
                "captures": {
                    "1": "support.function.constant.cpython.macro.c", 
                    "2": "string.support.cpython.identifier.c"
                }, 
                "match": "\\s*\\b(_Py_IDENTIFIER)\\b\\s*\\(\\s*([A-Za-z_]\\w*+)\\s*\\)"
            }, 
            {
                "captures": {
                    "1": "string.support.cpython.identifier.c"
                }, 
                "match": "\\s*\\bPyId_([A-Za-z_]\\w*+)\\b"
            }, 
            {
                "captures": {
                    "1": "support.constant.config.c"
                }, 
                "match": "\\s*\\b((?:CONFIG|HAVE)_[A-Z0-9_]++)\\b"
            }
        ], 
        "ppline-macro-head-object": [
            {
                "captures": {
                    "1": "keyword.other.preprocessor.define.c", 
                    "2": "entity.name.constant.preprocessor.c"
                }, 
                "match": "(?<!##)(?<=#)(\\s*define)\\s+([A-Za-z_]\\w*+)(?!\\()[\\s&&[^\\n]]*"
            }
        ], 
        "lex-keyword": [
            {
                "captures": {
                    "1": "keyword.control.c"
                }, 
                "match": "\\s*\\b((?:__|(?!\\w+__))asm(?:__)?|break|case|continue|default|do|else|for|goto|if|_Pragma|return|switch|typedef|while|__extension__)\\b"
            }, 
            {
                "captures": {
                    "1": "keyword.control.++c"
                }, 
                "match": "\\s*\\b(foreach)\\b"
            }
        ], 
        "lex-preprocessor": [
            {
                "include": "lex-comment"
            }, 
            {
                "include": "lex-continuation"
            }, 
            {
                "include": "lex-newline"
            }
        ], 
        "comment-banner-line": [
            {
                "captures": {
                    "1": "meta.toc-list.banner.c", 
                    "3": "punctuation.whitespace.newline.c"
                }, 
                "match": "(?:(?<=/[/\\*])|^)[\\s/*]*(=+\\s*(.*?)\\s*=+(?:(?=[\\s/*+\\-]*\\*/)|$(\\n?)))"
            }
        ], 
        "function-call-macro": [
            {
                "push": [
                    {
                        "meta_scope": "meta.function-call.constant.c"
                    }, 
                    {
                        "include": "lex"
                    }, 
                    {
                        "include": "support-macro"
                    }, 
                    {
                        "captures": {
                            "1": "variable.function.constant.c"
                        }, 
                        "match": "\\b([_A-Z][_A-Z0-9]*+)\\b"
                    }, 
                    {
                        "include": "parens-lookahead-end"
                    }, 
                    {
                        "match": "\\)", 
                        "pop": true
                    }
                ], 
                "match": "(?x)\n  \\s*\\b\n  (?= # don't consume string, to recognize support functions\n    (?: [_A-Z][_A-Z0-9]*+)\n    (?: \\s|/\\*.*?\\*/)*+\n    \\(\n  )"
            }
        ], 
        "block": [
            {
                "push": [
                    {
                        "match": "\\}", 
                        "pop": true
                    }, 
                    {
                        "include": "block-lookahead-end"
                    }
                ], 
                "match": "(?=\\{)"
            }
        ], 
        "lex-newline": [
            {
                "scope": "punctuation.whitespace.newline.c", 
                "match": "$\\n"
            }
        ], 
        "support": [
            {
                "include": "support-type"
            }, 
            {
                "include": "support-macro"
            }, 
            {
                "include": "support-function"
            }
        ], 
        "lex": [
            {
                "include": "lex-core"
            }, 
            {
                "include": "preprocessor"
            }
        ], 
        "ppline-include": [
            {
                "captures": {
                    "0": "keyword.other.preprocessor.include.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.preprocessor.include.c meta.preprocessor.c.include"
                    }, 
                    {
                        "captures": {
                            "1": "string.quoted.double.include.c", 
                            "2": "string.quoted.other.lt-gt.include.c", 
                            "3": "invalid.illegal.unexpected-end-of-line.c"
                        }, 
                        "match": "(?:(\"[^\"]*?)|(<[^>]*?))(\\n)|(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }, 
                    {
                        "include": "ppline-include-innards"
                    }
                ], 
                "match": "^\\s*(#)\\s*(include|include_next|import)\\b"
            }
        ], 
        "parens": [
            {
                "push": [
                    {
                        "include": "parens-lookahead-end"
                    }, 
                    {
                        "match": "\\)", 
                        "pop": true
                    }
                ], 
                "match": "(?=\\()"
            }
        ], 
        "block-special": [
            {
                "push": [
                    {
                        "match": "\\}", 
                        "pop": true
                    }, 
                    {
                        "include": "lex"
                    }, 
                    {
                        "push": [
                            {
                                "meta_scope": "meta.block.special.c"
                            }, 
                            {
                                "include": "$top_level_main"
                            }, 
                            {
                                "match": "(?=\\})", 
                                "pop": true
                            }
                        ], 
                        "match": "\\{"
                    }
                ], 
                "match": "(?x)\n  (?= \\s*\n    (?:\n        (?: \\b extern \\b\n            (?: \"(\\\\.|[^\"])*\" | '(\\\\.|[^'])*' | /\\*.*?\\*/ | \\s)*\n        )\n        |\n        (?: \\b namespace \\b\n            (?: (?: /\\*.*?\\*/ | \\s)* \\b [A-Za-z_]\\w*+ \\b)?\n            (?: /\\*.*?\\*/ | \\s)*\n        )\n    )\n    \\{\n  )"
            }
        ], 
        "string-escape-sequence": [
            {
                "scope": "constant.character.escape.c", 
                "match": "\\\\(\\\\|[abefnprtv'\"?]|[0-3]\\d{,2}|[4-7]\\d?|x[a-fA-F0-9]{,2}|u[a-fA-F0-9]{,4}|U[a-fA-F0-9]{,8})"
            }, 
            {
                "scope": "invalid.illegal.unknown-escape.c", 
                "match": "\\\\."
            }
        ], 
        "lex-core": [
            {
                "include": "lex-comment"
            }, 
            {
                "include": "lex-access"
            }, 
            {
                "include": "lex-continuation"
            }, 
            {
                "include": "lex-newline"
            }, 
            {
                "include": "lex-literal-number"
            }, 
            {
                "include": "lex-literal-string"
            }, 
            {
                "include": "lex-literal-regex"
            }, 
            {
                "include": "lex-keyword"
            }, 
            {
                "include": "lex-storage"
            }, 
            {
                "include": "lex-operator"
            }, 
            {
                "include": "lex-constant"
            }
        ], 
        "typedef": [
            {
                "push": [
                    {
                        "meta_scope": "meta.typedef.c"
                    }, 
                    {
                        "scope": "punctuation..terminator.c", 
                        "match": "(;)", 
                        "pop": true
                    }, 
                    {
                        "include": "lex"
                    }, 
                    {
                        "include": "type-definition"
                    }, 
                    {
                        "include": "block"
                    }, 
                    {
                        "captures": {
                            "1": "entity.name.type.typedef.c"
                        }, 
                        "match": "\\s*\\b([A-Za-z_]\\w*+)(?=\\s*[\\[;])"
                    }
                ], 
                "match": "(?x) (?<= \\A typedef | \\W typedef ) \\b"
            }
        ], 
        "ppline-pragma-mark": [
            {
                "captures": {
                    "1": "keyword.other.preprocessor.pragma.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.preprocessor.directive.pragma-mark.c"
                    }, 
                    {
                        "meta_content_scope": "meta.toc-list.pragma-mark.c"
                    }, 
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }, 
                    {
                        "include": "lex-preprocessor"
                    }, 
                    {
                        "scope": "string.other.pragma-mark.c", 
                        "match": "."
                    }
                ], 
                "match": "(^\\s*(#)\\s*(pragma\\s+mark)\\b)[\\s&&[^\\n]]*"
            }
        ], 
        "lex-access": [
            {
                "scope": "variable.other.member-access.c", 
                "match": "(?:(?<=\\.)|(?<=->))\\b([A-Za-z_]\\w*+)\\b(?!(?:\\s|/\\*.*?\\*/)*+\\()"
            }
        ], 
        "lex-type": [
            {
                "include": "type-declaration"
            }, 
            {
                "include": "type-definition"
            }
        ], 
        "preprocessor-disabled-directive": [
            {
                "push": [
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }
                ], 
                "match": "^\\s*(#)"
            }
        ], 
        "type-definition": [
            {
                "push": [
                    {
                        "meta_scope": "meta.compound.c"
                    }, 
                    {
                        "match": "(?x)\n  (?: (?!\\s*(?:[A-Za-z_({]|/[/*]|$))\n    | (?= \\s*\\b(?: [A-Za-z_]\\w*+ ) (?= \\s* [\\[;] ) )\n    | (?<!\\})(?=\n          # Prefer function definition over an attribute defined\n          # through a macro, unless a block has been seen. That is:\n          #   struct __packed __aligned(16) foo {...}; - function __aligned\n          #   struct foo {...} __packed __aligned(16); - structure foo\n          (?! \\s* \\b__attribute__\\b )\n\n          (?: ^\n            | (?<! (?<!\\w) new\n                  | (?<!\\w) (?:else|enum) | (?<!\\w) (?:class|union)\n                  | (?<!\\w) (?:struct|return|sizeof|typeof)\n                  | (?<!\\w) __typeof | (?<!\\w) __typeof__ )\n              (?<= \\w ) \\s\n\n            | #  or type modifier / closing bracket before name\n              (?<= [^&]& | [*>)}\\]] ) ) \\s*\n\n          (?: [A-Za-z_]\\w*+ | ::[^:] | \\. )++\n          (?: (?<= ^ operator | \\W operator )  # C++ operator?\n              (?: [-*&<>=+!]+ | \\(\\) | \\[\\] ) )?\n          (?:\\s|/\\*.*?\\*/)*+ \\( ) )", 
                        "pop": true
                    }, 
                    {
                        "push": [
                            {
                                "include": "lex"
                            }, 
                            {
                                "include": "block"
                            }, 
                            {
                                "include": "parens"
                            }, 
                            {
                                "match": "(?!\\s*(?:[A-Za-z_({]|/[/*]|$))", 
                                "pop": true
                            }
                        ], 
                        "match": "(?<=\\})"
                    }, 
                    {
                        "include": "lex"
                    }, 
                    {
                        "include": "block"
                    }, 
                    {
                        "include": "parens"
                    }, 
                    {
                        "captures": {
                            "1": "entity.name.type.class.c entity.name.class.c"
                        }, 
                        "match": "\\b([A-Za-z_]\\w*+)(?=(?:\\s|/\\*.*?\\*/)*+(?:\\{|(//.*)?\\\\?$))"
                    }
                ], 
                "match": "(?x)\n  (?<=  \\A enum | \\A (?:class|union) | \\A struct |\n        \\W enum | \\W (?:class|union) | \\W struct )\n  \\b\n  # Negation of zero-length parts of the end pattern\n  # to prevent entering the rule if it's gonna exit immediately.\n  # (workaround ST2 bugs, see issue #10)\n  (?=\\s*(?:[A-Za-z_({]|/[/*]|$))\n  (?! \\s*\\b(?: [A-Za-z_]\\w*+ ) (?= \\s* [\\[;] ) )"
            }
        ], 
        "ppline-macro-head-function": [
            {
                "captures": {
                    "1": "keyword.other.preprocessor.define.c", 
                    "2": "entity.name.function.preprocessor.c", 
                    "3": "meta.preprocessor.macro.parameters.c"
                }, 
                "push": [
                    {
                        "meta_content_scope": "meta.preprocessor.macro.parameters.c"
                    }, 
                    {
                        "captures": {
                            "1": "invalid.illegal.unexpected-end-of-line.c"
                        }, 
                        "match": "(?<=\\))|(?<=^|[^\\\\])\\s*(\\n)", 
                        "pop": true
                    }, 
                    {
                        "match": "\\)"
                    }, 
                    {
                        "captures": {
                            "1": "variable.parameter.c"
                        }, 
                        "push": [
                            {
                                "match": "(?<=\\))|(?=(?<=^|[^\\\\])\\s*(\\n))", 
                                "pop": true
                            }, 
                            {
                                "match": "\\)"
                            }, 
                            {
                                "include": "ppline-macro-param-next"
                            }, 
                            {
                                "include": "ppline-macro-param-vararg"
                            }, 
                            {
                                "include": "ppline-macro-param-lex"
                            }, 
                            {
                                "include": "ppline-macro-param-lex-invalid"
                            }
                        ], 
                        "match": "\\b([A-Za-z_]\\w*+)\\b"
                    }, 
                    {
                        "include": "ppline-macro-param-vararg"
                    }, 
                    {
                        "include": "ppline-macro-param-lex"
                    }, 
                    {
                        "include": "ppline-macro-param-lex-invalid"
                    }
                ], 
                "match": "(?<!##)(?<=#)(\\s*define)\\s+([A-Za-z_]\\w*+)(\\()"
            }
        ], 
        "ppline-include-innards": [
            {
                "include": "lex-preprocessor"
            }, 
            {
                "captures": {
                    "0": "punctuation.definition.string.begin.c"
                }, 
                "push": [
                    {
                        "meta_scope": "string.quoted.double.include.c"
                    }, 
                    {
                        "captures": {
                            "0": "punctuation.definition.string.end.c"
                        }, 
                        "match": "\"|(?<=^|[^\\\\])(?=\\s*\\n)", 
                        "pop": true
                    }
                ], 
                "match": "\"|(?=.*?\")"
            }, 
            {
                "captures": {
                    "0": "punctuation.definition.string.begin.c"
                }, 
                "push": [
                    {
                        "meta_scope": "string.quoted.other.lt-gt.include.c"
                    }, 
                    {
                        "captures": {
                            "0": "punctuation.definition.string.end.c"
                        }, 
                        "match": ">|(?<=^|[^\\\\])(?=\\s*\\n)", 
                        "pop": true
                    }
                ], 
                "match": "<(?=.*?>)"
            }, 
            {
                "push": [
                    {
                        "meta_scope": "meta.parens.c"
                    }, 
                    {
                        "match": "\\)|(?<=^|[^\\\\])(?=\\s*\\n)", 
                        "pop": true
                    }, 
                    {
                        "include": "ppline-include-innards"
                    }
                ], 
                "match": "\\("
            }
        ], 
        "comment-note": [
            {
                "captures": {
                    "0": "comment.command.c", 
                    "1": "storage.type.class.note.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.toc-list.task-tag.note.c"
                    }, 
                    {
                        "match": "(?=[\\s/*]*\\*/)|(?<=$\\n)", 
                        "pop": true
                    }
                ], 
                "match": "(?ix)\n    (?= (?-i: \\b [A-Z_]++) \\b) @? \\b\n    ( TODO\n    | NOTE\n    | NB\n    | TBD\n    | REVIEW\n    | CHANGED\n    | IDEA\n    | IMPORTANT\n    | HACK\n    | BUG\n    | DEPRECATED\n    ) \\b"
            }
        ], 
        "support-type": [
            {
                "captures": {
                    "1": "support.type.stdlib.c"
                }, 
                "match": "\\s*\\b(u_char|u_short|u_int|u_long|ushort|uint|(?:u_quad|quad|qaddr|caddr|daddr|dev|fixpt|blkcnt|blksize|gid|in_addr|in_port|ino|key|mode|nlink|id|pid|off|segsz|swblk|uid|id|clock|size|ssize|time|useconds|suseconds|siginfo)_t)\\b"
            }, 
            {
                "captures": {
                    "1": "support.type.stdint.c"
                }, 
                "match": "\\s*\\b(u?int(?:(?:_least|_fast)?(?:8|16|32|64)_t|ptr_t|max_t))\\b"
            }, 
            {
                "captures": {
                    "1": "support.type.stdarg.c"
                }, 
                "match": "\\s*\\b(va_list)\\b"
            }, 
            {
                "captures": {
                    "1": "support.type.libccc.++c"
                }, 
                "match": "\\s*\\b([tseuf]_\\w+)\\b"
            }, 
            {
                "captures": {
                    "1": "support.type.pthread.c"
                }, 
                "match": "\\s*\\b(pthread_(?:t|attr_t|once_t|key_t|(?:cond|mutex|rwlock)(?:attr)?_t))\\b"
            }, 
            {
                "captures": {
                    "1": "support.type.libuv.c"
                }, 
                "match": "\\s*\\b(uv_\\w+_t)\\b"
            }, 
            {
                "captures": {
                    "1": "support.type.SDL2.c"
                }, 
                "match": "\\s*\\b((SDL_([A-Z][a-z]+)\\w+(?!\\()))\\b"
            }
        ], 
        "preprocessor": [
            {
                "push": [
                    {
                        "match": "(?!^\\s*(#))", 
                        "pop": true
                    }, 
                    {
                        "include": "preprocessor-disabled"
                    }, 
                    {
                        "include": "ppline-directive-invalid-usage"
                    }, 
                    {
                        "include": "ppline-macro"
                    }, 
                    {
                        "include": "ppline-undef"
                    }, 
                    {
                        "include": "ppline-pragma-mark"
                    }, 
                    {
                        "include": "ppline-include"
                    }, 
                    {
                        "include": "ppline-plusplusc"
                    }, 
                    {
                        "include": "ppline-directive"
                    }, 
                    {
                        "include": "ppline-directive-obsolete"
                    }, 
                    {
                        "include": "ppline-invalid"
                    }, 
                    {
                        "include": "ppline-any"
                    }
                ], 
                "match": "(?=^\\s*(#))"
            }
        ], 
        "comment-command": [
            {
                "captures": {
                    "0": "comment.c", 
                    "1": "comment.command.c"
                }, 
                "match": "\\b(?:[A-Za-z_]\\w+)(\\(\\))"
            }, 
            {
                "captures": {
                    "0": "comment.c", 
                    "1": "comment.command.c"
                }, 
                "match": "\\b(#)(?:[A-Za-z_]\\w+)\\b"
            }, 
            {
                "captures": {
                    "0": "comment.command.c"
                }, 
                "match": "@[{}]"
            }, 
            {
                "captures": {
                    "0": "comment.command.c", 
                    "1": "comment.command.user.c", 
                    "2": "comment.command.c", 
                    "3": "comment.command.user.c"
                }, 
                "match": "(?ix)\n  (?= (?-i: [@\\\\][A-Za-z_]++) \\b) [@\\\\]? \\b\n  ( GROUP\n  | ALIAS\n  | ARG\n  | ISOSTD\n  | NONSTD\n  | ERRORS\n  | PARAM_ENV\n  | PARAM_WORKER\n  | PARAM_RESULT\n  | (?:END)?EXAMPLES\n  | (?:END)?EXAMPLECODE\n  ) \\b\n  ({([^}]*)})?"
            }, 
            {
                "captures": {
                    "0": "comment.command.c", 
                    "1": "comment.command.doxygen.c", 
                    "2": "comment.command.doxygen.group-brace.c", 
                    "3": "comment.command.doxygen.group-close.c", 
                    "4": "comment.command.doxygen.c"
                }, 
                "match": "(?ix)\n  [@\\\\] \\b\n  (?:\n    ( ({) | (})\n    | ADDINDEX\n    | ARG\n    | ATTENTION\n    | AUTHOR\n    | AUTHORS\n    | BRIEF\n    | BUG\n    | CALLERGRAPH\n    | CALLGRAPH\n    | CODE\n    | COND\n    | COPYRIGHT\n    | DATE\n    | DEPRECATED\n    | DETAILS\n    | DOCBOOKONLY\n    | DOT\n    | ELSE\n    | ELSEIF\n    | EMOJI\n    | ENDCODE\n    | ENDCOND\n    | ENDDOCBOOKONLY\n    | ENDDOT\n    | ENDHTMLONLY\n    | ENDIF\n    | ENDINTERNAL\n    | ENDLATEXONLY\n    | ENDLINK\n    | ENDMANONLY\n    | ENDMSC\n    | ENDPARBLOCK\n    | ENDRTFONLY\n    | ENDSECREFLIST\n    | ENDVERBATIM\n    | ENDUML\n    | ENDXMLONLY\n    | EXCEPTION\n    | EXTENDS\n    | FN\n    | FILE\n    | HIDECALLERGRAPH\n    | HIDECALLGRAPH\n    | HIDEREFBY\n    | HIDEREFS\n    | HIDEINITIALIZER\n    | HTMLONLY\n    | IF\n    | IFNOT\n    | IMAGE\n    | INTERNAL\n    | INVARIANT\n    | LATEXONLY\n    | LI\n    | LINE\n    | MAINPAGE\n    | MANONLY\n    | MSC\n    | N\n    | NAME\n    | NOOP\n    | NOSUBGROUPING\n    | NOTE\n    | OVERLOAD\n    | PARBLOCK\n    | POST\n    | PRE\n    | PRIVATE\n    | PRIVATESECTION\n    | PROPERTY\n    | PROTECTED\n    | PROTECTEDSECTION\n    | PUBLIC\n    | PUBLICSECTION\n    | PURE\n    | REMARK\n    | REMARKS\n    | RESULT\n    | RETURN\n    | RETURNS\n    | RETVAL\n    | RTFONLY\n    | SA\n    | SECREFLIST\n    | SECTION\n    | SEE\n    | SHORT\n    | SHOWINITIALIZER\n    | SHOWREFBY\n    | SHOWREFS\n    | SINCE\n    | SKIP\n    | SKIPLINE\n    | STATIC\n    | STARTUML\n    | TABLEOFCONTENTS\n    | TEST\n    | THROW\n    | THROWS\n    | TODO\n    | TPARAM\n    | UNTIL\n    | VERBATIM\n    | VERSION\n    | VHDLFLOW\n    | WARNING\n    | XMLONLY\n    | XREFITEM\n    ) \\b |\n    ( F[\\$\\[\\]\\{\\}]\n    | \\$\n    | \\@\n    | \\\\\n    | \\&\n    | \\~\n    | \\<\n    | \\=\n    | \\>\n    | \\#\n    | \\%\n    | \\\"\n    | \\.\n    | \\|\n    | ::\n    | --\n    | ---\n    )\n  )"
            }, 
            {
                "captures": {
                    "0": "comment.command.c", 
                    "1": "comment.command.doxygen.c", 
                    "2": "comment.command.doxygen.group-brace.c", 
                    "3": "comment.command.doxygen.group-close.c", 
                    "4": "comment.command.user.c"
                }, 
                "match": "(?ix)\n    [@\\\\] \\b\n    ( ({) | (})\n    | A\n    | ADDTOGROUP\n    | ANCHOR\n    | B\n    | C\n    | CATEGORY\n    | CITE\n    | CLASS\n    | COPYBRIEF\n    | COPYDETAILS\n    | COPYDOC\n    | DEF\n    | DEFGROUP\n    | DIAFILE\n    | DIR\n    | DOCBOOKINCLUDE\n    | DONTINCLUDE\n    | DOTFILE\n    | E\n    | EM\n    | ENUM\n    | EXAMPLE\n    | FILE\n    | HEADERFILE\n    | HTMLINCLUDE\n    | IDLEXCEPT\n    | IMPLEMENTS\n    | INCLUDE\n    | INCLUDEDOC\n    | INCLUDELINENO\n    | INGROUP\n    | INTERFACE\n    | LATEXINCLUDE\n    | LINK\n    | MANINCLUDE\n    | MEMBEROF\n    | MSCFILE\n    | NAMESPACE\n    | P\n    | PACKAGE\n    | PAGE\n    | PAR\n    | PARAM\n    | PARAGRAPH\n    | PROTOCOL\n    | REF\n    | REFITEM\n    | RELATED\n    | RELATES\n    | RELATEDALSO\n    | RELATESALSO\n    | RTFINCLUDE\n    | SNIPPET\n    | SNIPPETDOC\n    | SNIPPETLINENO\n    | STRUCT\n    | SUBPAGE\n    | SUBSECTION\n    | SUBSUBSECTION\n    | TYPEDEF\n    | UNION\n    | VAR\n    | VERBINCLUDE\n    | WEAKGROUP\n    | XMLINCLUDE\n    ) \\b\n    [\\t\\ ]*([^\\s]+)"
            }
        ], 
        "lex-literal-string": [
            {
                "captures": {
                    "0": "punctuation.definition.string.begin.c"
                }, 
                "push": [
                    {
                        "meta_scope": "string.quoted.double.c"
                    }, 
                    {
                        "include": "lex-continuation"
                    }, 
                    {
                        "include": "string-escape-sequence"
                    }, 
                    {
                        "include": "string-format-specifier"
                    }, 
                    {
                        "captures": {
                            "1": "punctuation.definition.string.end.c", 
                            "2": "invalid.illegal.unexpected-end-of-line.c"
                        }, 
                        "match": "(\")|(?<=^|[^\\\\])\\s*(\\n)", 
                        "pop": true
                    }
                ], 
                "match": "\""
            }, 
            {
                "captures": {
                    "0": "punctuation.definition.string.begin.c"
                }, 
                "push": [
                    {
                        "meta_scope": "string.quoted.single.c"
                    }, 
                    {
                        "include": "lex-continuation"
                    }, 
                    {
                        "include": "string-escape-sequence"
                    }, 
                    {
                        "captures": {
                            "1": "punctuation.definition.string.end.c", 
                            "2": "invalid.illegal.unexpected-end-of-line.c"
                        }, 
                        "match": "(')|(?<=^|[^\\\\])\\s*(\\n)", 
                        "pop": true
                    }
                ], 
                "match": "'"
            }
        ], 
        "regexp": [
            {
                "scope": "keyword.control.anchor.regexp", 
                "match": "\\\\[bB]|\\^|\\$"
            }, 
            {
                "captures": {
                    "0": "keyword.other.back-reference.regexp", 
                    "1": "variable.other.regexp"
                }, 
                "match": "\\\\[1-9]\\d*|\\\\k<([a-zA-Z_$][\\w$]*)>"
            }, 
            {
                "scope": "keyword.operator.quantifier.regexp", 
                "match": "[?+*]|\\{(\\d+,\\d+|\\d+,|,\\d+|\\d+)\\}\\??"
            }, 
            {
                "scope": "keyword.operator.or.regexp", 
                "match": "\\|"
            }, 
            {
                "captures": {
                    "1": "punctuation.definition.group.regexp", 
                    "2": "punctuation.definition.group.assertion.regexp", 
                    "3": "meta.assertion.look-ahead.regexp", 
                    "4": "meta.assertion.negative-look-ahead.regexp", 
                    "5": "meta.assertion.look-behind.regexp", 
                    "6": "meta.assertion.negative-look-behind.regexp"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.group.assertion.regexp"
                    }, 
                    {
                        "captures": {
                            "1": "punctuation.definition.group.regexp"
                        }, 
                        "match": "(\\))", 
                        "pop": true
                    }, 
                    {
                        "include": "regexp"
                    }
                ], 
                "match": "(\\()((\\?=)|(\\?!)|(\\?<=)|(\\?<!))"
            }, 
            {
                "captures": {
                    "0": "punctuation.definition.group.regexp", 
                    "1": "punctuation.definition.group.no-capture.regexp", 
                    "2": "variable.other.regexp"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.group.regexp"
                    }, 
                    {
                        "captures": {
                            "0": "punctuation.definition.group.regexp"
                        }, 
                        "match": "\\)", 
                        "pop": true
                    }, 
                    {
                        "include": "regexp"
                    }
                ], 
                "match": "\\((?:(\\?:)|(?:\\?<([a-zA-Z_$][\\w$]*)>))?"
            }, 
            {
                "captures": {
                    "1": "punctuation.definition.character-class.regexp", 
                    "2": "keyword.operator.negation.regexp"
                }, 
                "push": [
                    {
                        "meta_scope": "constant.other.character-class.set.regexp"
                    }, 
                    {
                        "captures": {
                            "1": "punctuation.definition.character-class.regexp"
                        }, 
                        "match": "(\\])", 
                        "pop": true
                    }, 
                    {
                        "scope": "constant.other.character-class.range.regexp", 
                        "captures": {
                            "1": "constant.character.numeric.regexp", 
                            "2": "constant.character.control.regexp", 
                            "3": "constant.character.escape.backslash.regexp", 
                            "4": "constant.character.numeric.regexp", 
                            "5": "constant.character.control.regexp", 
                            "6": "constant.character.escape.backslash.regexp"
                        }, 
                        "match": "(?:.|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))\\-(?:[^\\]\\\\]|(\\\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\\\c[A-Z])|(\\\\.))"
                    }, 
                    {
                        "include": "regex-character-class"
                    }
                ], 
                "match": "(\\[)(\\^)?"
            }, 
            {
                "include": "regex-character-class"
            }
        ], 
        "ppline-directive": [
            {
                "captures": {
                    "0": "keyword.other.preprocessor.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.preprocessor.directive.c"
                    }, 
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }, 
                    {
                        "include": "lex-core"
                    }, 
                    {
                        "include": "macro"
                    }
                ], 
                "match": "^\\s*(#)\\s*(if|ifdef|ifndef|elif|else|endif|pragma|line|define|undef|error|warning)\\b"
            }, 
            {
                "captures": {
                    "0": "keyword.other.preprocessor.++c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.preprocessor.directive.++c"
                    }, 
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }, 
                    {
                        "include": "lex-core"
                    }
                ], 
                "match": "^\\s*(#)\\s*(namespace|function|operator|accessor|incbin|header|reflect|alias|align|inline|format|noreturn|malloc|delete|packed|pure)\\b"
            }, 
            {
                "captures": {
                    "0": "keyword.other.preprocessor.include.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.preprocessor.include.c meta.preprocessor.c.include"
                    }, 
                    {
                        "captures": {
                            "1": "string.quoted.double.include.c", 
                            "2": "string.quoted.other.lt-gt.include.c", 
                            "3": "invalid.illegal.unexpected-end-of-line.c"
                        }, 
                        "match": "(?:(\"[^\"]*?)|(<[^>]*?))(\\n)|(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }, 
                    {
                        "include": "ppline-include-innards"
                    }
                ], 
                "match": "^\\s*(#)\\s*(replace)\\b"
            }
        ], 
        "ppline-macro": [
            {
                "captures": {
                    "0": "keyword.other.preprocessor.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.preprocessor.macro.c"
                    }, 
                    {
                        "include": "ppline-macro-head-function"
                    }, 
                    {
                        "include": "ppline-macro-head-object"
                    }, 
                    {
                        "include": "lex-core"
                    }, 
                    {
                        "include": "ppline-macro-operator"
                    }, 
                    {
                        "include": "function"
                    }, 
                    {
                        "include": "support"
                    }, 
                    {
                        "include": "block"
                    }, 
                    {
                        "include": "parens"
                    }, 
                    {
                        "include": "macro"
                    }, 
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }
                ], 
                "match": "^\\s*(#)(?=\\s*(define)\\s+[A-Za-z_]\\w*+)"
            }
        ], 
        "lex-constant": [
            {
                "captures": {
                    "1": "constant.language.c"
                }, 
                "match": "\\s*\\b(NULL|TRUE|FALSE)\\b"
            }, 
            {
                "captures": {
                    "1": "constant.language.++c"
                }, 
                "match": "\\s*\\b(null|true|false|ERROR|OK)\\b"
            }
        ], 
        "comment": [
            {
                "include": "comment-note"
            }, 
            {
                "include": "comment-banner-line"
            }, 
            {
                "include": "lex-continuation"
            }, 
            {
                "include": "lex-newline"
            }
        ], 
        "block-lookahead-end": [
            {
                "push": [
                    {
                        "meta_scope": "meta.block.c"
                    }, 
                    {
                        "include": "typedef"
                    }, 
                    {
                        "include": "lex-type"
                    }, 
                    {
                        "include": "lex"
                    }, 
                    {
                        "include": "support"
                    }, 
                    {
                        "include": "function"
                    }, 
                    {
                        "include": "variable-declaration"
                    }, 
                    {
                        "include": "macro"
                    }, 
                    {
                        "include": "variable"
                    }, 
                    {
                        "include": "ppline-macro-operator"
                    }, 
                    {
                        "include": "$top_level_main"
                    }, 
                    {
                        "match": "(?=\\})", 
                        "pop": true
                    }
                ], 
                "match": "\\{"
            }
        ], 
        "macro": [
            {
                "captures": {
                    "1": "variable.language.c"
                }, 
                "match": "\\b(__VA_ARGS__)\\b"
            }, 
            {
                "captures": {
                    "1": "variable.other.constant.c"
                }, 
                "match": "\\b(__\\w++(?:__)?)\\b"
            }, 
            {
                "captures": {
                    "1": "variable.other.constant.c"
                }, 
                "match": "\\b([_A-Z][_A-Z0-9]++)\\b"
            }
        ], 
        "translation_unit": [
            {
                "include": "block-special"
            }, 
            {
                "include": "typedef"
            }, 
            {
                "include": "lex-type"
            }, 
            {
                "include": "lex"
            }, 
            {
                "include": "function"
            }, 
            {
                "include": "support"
            }, 
            {
                "include": "block"
            }, 
            {
                "include": "parens"
            }
        ], 
        "regex-character-class": [
            {
                "scope": "constant.other.character-class.regexp", 
                "match": "\\\\[wWsSdDtrnvf]|\\."
            }, 
            {
                "scope": "constant.character.numeric.regexp", 
                "match": "\\\\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})"
            }, 
            {
                "scope": "constant.character.control.regexp", 
                "match": "\\\\c[A-Z]"
            }, 
            {
                "scope": "constant.character.escape.backslash.regexp", 
                "match": "\\\\."
            }
        ], 
        "ppline-macro-param-vararg": [
            {
                "captures": {
                    "1": "punctuation.definition.ellipsis.c"
                }, 
                "push": [
                    {
                        "match": "(\\))|(?=(?<=^|[^\\\\])\\s*(\\n))", 
                        "pop": true
                    }, 
                    {
                        "include": "ppline-macro-param-lex"
                    }, 
                    {
                        "scope": "invalid.illegal.unexpected-character.c", 
                        "match": "(?x)\n  (?: (?! (?:\\s|/\\*.*?\\*/)*+\n        (?: \\) | (?>(?:\\\\\\s*)?$\\n?) | /[/*] ) )\n      .)*"
                    }
                ], 
                "match": "(\\.\\.\\.)"
            }
        ], 
        "type-declaration": [
            {
                "push": [
                    {
                        "meta_scope": "meta.compound.c"
                    }, 
                    {
                        "match": "(?<=;)", 
                        "pop": true
                    }, 
                    {
                        "include": "lex"
                    }, 
                    {
                        "captures": {
                            "1": "entity.name.type.declaration.c"
                        }, 
                        "match": "\\s*\\b([A-Za-z_]\\w*+)\\b"
                    }
                ], 
                "match": "(?x)\n  (?<=  \\A enum | \\A (?:class|union) | \\A struct |\n        \\W enum | \\W (?:class|union) | \\W struct )\n  \\b\n  (?= (?:\\s|/\\*.*?\\*/)*+\n      ([A-Za-z_]\\w*+)\n      (?:\\s|/\\*.*?\\*/)*+;\n  )"
            }
        ], 
        "variable": [
            {
                "captures": {
                    "1": "variable.other.c"
                }, 
                "match": "\\b([A-Za-z_]\\w*+)\\b"
            }
        ], 
        "variable-declaration": [
            {
                "captures": {
                    "1": "entity.name.variable.declaration.c"
                }, 
                "match": "(?x)\n  (?: (?<! (?<!\\w) new\n        | (?<!\\w) (?:else|enum)\n        | (?<!\\w) (?:class|union)\n        | (?<!\\w) (?:struct|return|sizeof|typeof)\n        | (?<!\\w) __typeof | (?<!\\w) __typeof__\n      )\n      (?<= \\w\\b)\n    | #  or type modifier / closing bracket before name\n      (?<= [*>)}\\]] )\n  )\n  \\s*+\n  (   (?: [A-Za-z_]\\w*+ | ::[^:] )++ )\n  (?=\n    (?:\\s|/\\*.*?\\*/)*+\n    [=;,\\)\\[]\n  )"
            }
        ], 
        "ppline-macro-param-next": [
            {
                "captures": {
                    "1": "punctuation.separator.parameter.c"
                }, 
                "push": [
                    {
                        "captures": {
                            "1": "variable.parameter.c", 
                            "2": "invalid.illegal.unexpected-closing-paren.c"
                        }, 
                        "match": "\\b([A-Za-z_]\\w*+)\\b|(?=\\.\\.\\.)|(\\))|(?=(?<=^|[^\\\\])\\s*(\\n))", 
                        "pop": true
                    }, 
                    {
                        "include": "ppline-macro-param-lex"
                    }, 
                    {
                        "scope": "invalid.illegal.unexpected-character.c", 
                        "match": "(?x)\n  (?: (?! (?:\\s|/\\*.*?\\*/)*+\n        (?: \\b([A-Za-z_]\\w*+)\\b | \\.\\.\\. | \\) | (?>(?:\\\\\\s*)?$\\n?) | /[/*] ) )\n      .)*"
                    }
                ], 
                "match": "(,)"
            }
        ], 
        "parens-lookahead-end": [
            {
                "push": [
                    {
                        "meta_scope": "meta.parens.c"
                    }, 
                    {
                        "include": "lex-type"
                    }, 
                    {
                        "include": "lex"
                    }, 
                    {
                        "include": "support"
                    }, 
                    {
                        "include": "function-pointer"
                    }, 
                    {
                        "include": "function-call-macro"
                    }, 
                    {
                        "include": "function-call"
                    }, 
                    {
                        "include": "variable-declaration"
                    }, 
                    {
                        "include": "macro"
                    }, 
                    {
                        "include": "variable"
                    }, 
                    {
                        "include": "ppline-macro-operator"
                    }, 
                    {
                        "include": "$top_level_main"
                    }, 
                    {
                        "match": "(?=\\))", 
                        "pop": true
                    }
                ], 
                "match": "\\("
            }
        ], 
        "lex-literal-number": [
            {
                "scope": "constant.numeric.float.hexadecimal.c", 
                "captures": {
                    "1": "constant.numeric.other.prefix.c", 
                    "2": "invalid.illegal.number.missing-fragment.significand.c", 
                    "3": "invalid.illegal.numeric-literal-character.float.whole-number.c", 
                    "4": "invalid.illegal.numeric-literal-character.float.fraction.c", 
                    "5": "keyword.other.exponent.hexadecimal.c", 
                    "6": "invalid.illegal.numeric-literal-character.float.exponent.c", 
                    "7": "invalid.illegal.numeric-literal-character.float.exponent.c", 
                    "8": "invalid.illegal.number.missing-fragment.exponent.c", 
                    "9": "constant.numeric.other.suffix.c"
                }, 
                "match": "(?ix)  # hexadecimal float literal\n  (?<!\\.) \\b\n\n  (0x)\n\n  # significand\n  (?: (\\.) (?=p)  # invalid\n    |        [0-9a-f]*+ ([0-9a-z]*?) [0-9a-f]*+\n      (?: \\. [0-9a-f]*+ ([0-9a-z.]*?) [0-9a-f]*+ )? )\n\n  # exponent (required)\n  (?: (p) (?:        [+\\-]  [0-9]++ ([0-9a-z]*?)\n            | (?=[0-9a-z.]) [0-9]*+ ([0-9a-z.]*?) )\n    | (p) )\n\n  # remaining valid chars and type specifier suffix\n  [0-9]*+ ([fl]?)\n\n  \\b (?!\\.)"
            }, 
            {
                "scope": "constant.numeric.float.hexadecimal.c", 
                "captures": {
                    "1": "constant.numeric.other.prefix.c", 
                    "2": "invalid.illegal.numeric-literal-character.float.whole-number.c", 
                    "3": "invalid.illegal.number.hexadecimal-float-requires-exponent.c", 
                    "4": "invalid.illegal.numeric-literal-character.float.fraction.c", 
                    "5": "constant.numeric.other.suffix.c"
                }, 
                "match": "(?ix)  # hexadecimal float literal, without required exponent\n  (?<!\\.) \\b\n\n  (0x)\n\n  # significand (at least a period)\n       [0-9a-f]*+ ([0-9a-z&&[^p]]*?) [0-9a-f]*+\n  (\\.) [0-9a-f]*+ ([0-9a-z.&&[^p]]*?) [0-9a-f]*+\n\n  # type specifier suffix\n  (l?)\n\n  (?:(?<=\\.)|\\b) (?!\\.)"
            }, 
            {
                "scope": "constant.numeric.float.c", 
                "captures": {
                    "1": "invalid.illegal.numeric-literal-character.float.whole-number.c", 
                    "2": "invalid.illegal.numeric-literal-character.float.fraction.c", 
                    "3": "invalid.illegal.numeric-literal-character.float.whole-number.c", 
                    "4": "keyword.other.exponent.decimal.c", 
                    "5": "invalid.illegal.numeric-literal-character.float.exponent.c", 
                    "6": "invalid.illegal.numeric-literal-character.float.exponent.c", 
                    "7": "invalid.illegal.numeric-literal-character.float.exponent.c", 
                    "8": "invalid.illegal.numeric-literal-character.float.exponent.c", 
                    "9": "constant.numeric.other.suffix.c"
                }, 
                "match": "(?ix)  # decimal float literal\n  (?<!\\.) (?:(?=\\.)|\\b)\n\n  (?!0x)\n  # significand\n  (?: (?: [0-9]++ ([0-9a-z&&[^e]]*?) [0-9]*+ )?\n      \\.  [0-9]++ ([0-9a-z.&&[^e]]*?) [0-9]*+\n\n    |     [0-9]++ ([0-9a-z&&[^e]]*?) [0-9]*+ (?: \\. | (?=e)) )\n\n  # exponent (optional)\n  (?: (e) (?: [+\\-]  [0-9]++ ([0-9a-z]*?)\n            |        [0-9]++ ([0-9a-z.]*?) )\n    | ( p     [+\\-]? [0-9]++\n      | [ep]                  [0-9a-z.]*?) )?\n\n  # any invalid chars and type specifier suffix\n  ([0-9a-z]*?) [0-9]*+ ([fl]?)\n\n  (?:(?<=\\.)|\\b) (?!\\.)"
            }, 
            {
                "scope": "constant.numeric.integer.zero.c", 
                "captures": {
                    "1": "constant.numeric.other.prefix.c", 
                    "2": "constant.numeric.other.suffix.c"
                }, 
                "match": "(?ix) # zero\n  (?<!\\.)\n  \\b\n  (0[xbo])?           # literal prefix\n  0++                 # iterate over number characters\n  (u?l{0,2}|lul?|llu) # type specifier suffix, if any\n  \\b\n  (?!\\.)"
            }, 
            {
                "scope": "invalid.illegal.invalid-number-literal.c", 
                "match": "(?ix) # invalid (empty) number literal\n  (?<!\\.)\n  \\b\n  (?: (0x) | (0b) )   # literal prefix\n  (u?l{0,2}|lul?|llu) # type specifier suffix, if any\n  \\b\n  (?!\\.)"
            }, 
            {
                "scope": "constant.numeric.integer.hexadecimal.c", 
                "captures": {
                    "1": "constant.numeric.other.prefix.c", 
                    "2": "invalid.illegal.numeric-literal-character.integer.c", 
                    "3": "constant.numeric.other.suffix.c"
                }, 
                "match": "(?ix) # hexadecimal integer literal\n  (?<!\\.)\n  \\b\n  (0x)                # literal prefix\n  [0-9a-f]++          # iterate over number characters\n  ([0-9a-z]*?)        # find any invalid chars\n  [0-9a-f]*           # the remainder (after invalid chars, if any)\n  (u?l{0,2}|lul?|llu) # type specifier suffix, if any\n  \\b\n  (?!\\.)"
            }, 
            {
                "scope": "constant.numeric.integer.binary.c", 
                "captures": {
                    "1": "constant.numeric.other.prefix.c", 
                    "2": "invalid.illegal.numeric-literal-character.integer.c", 
                    "3": "constant.numeric.other.suffix.c"
                }, 
                "match": "(?ix) # binary integer literal\n  (?<!\\.)\n  \\b\n  (0b)                # literal prefix\n  [01]++              # iterate over number characters\n  ([0-9a-z]*?)        # find any invalid chars\n  [01]*               # the remainder (after invalid chars, if any)\n  (u?l{0,2}|lul?|llu) # type specifier suffix, if any\n  \\b\n  (?!\\.)"
            }, 
            {
                "scope": "constant.numeric.integer.octal.c", 
                "captures": {
                    "1": "constant.numeric.other.prefix.c", 
                    "2": "invalid.illegal.numeric-literal-character.integer.c", 
                    "3": "constant.numeric.other.suffix.c"
                }, 
                "match": "(?ix) # octal integer literal\n  (?<!\\.)\n  \\b\n  (0|0o)              # literal prefix\n  [0-7]++             # iterate over number characters\n  ([0-9a-z]*?)        # find any invalid chars\n  [0-7]*              # the remainder (after invalid chars, if any)\n  (u?l{0,2}|lul?|llu) # type specifier suffix, if any\n  \\b\n  (?!\\.)"
            }, 
            {
                "scope": "constant.numeric.integer.decimal.c", 
                "captures": {
                    "1": "invalid.illegal.numeric-literal-character.integer.c", 
                    "2": "constant.numeric.other.suffix.c"
                }, 
                "match": "(?ix) # decimal integer literal\n  (?<!\\.)\n  \\b\n  [0-9]++             # iterate over number characters\n  ([0-9a-z]*?)        # find any invalid chars\n  [0-9]*              # the remainder (after invalid chars, if any)\n  (u?l{0,2}|lul?|llu) # type specifier suffix, if any\n  \\b\n  (?!\\.)"
            }
        ], 
        "function-pointer": [
            {
                "captures": {
                    "1": "entity.name.variable.c", 
                    "2": "punctuation.terminator.c"
                }, 
                "match": "(?<=\\()(?:\\s*\\*\\s*)([A-Za-z_]\\w*+)(?:\\s*\\)\\s*\\()(;)"
            }
        ], 
        "comment-documentation": [
            {
                "include": "comment-note"
            }, 
            {
                "include": "comment-command"
            }, 
            {
                "include": "lex-continuation"
            }, 
            {
                "include": "lex-newline"
            }
        ], 
        "ppline-macro-param-lex-invalid": [
            {
                "scope": "invalid.illegal.unexpected-character.c", 
                "match": "(?x)\n  (?: (?! (?:\\s|/\\*.*?\\*/)*+\n          (?: \\) | (?>(?:\\\\\\s*)?$\\n?) | /[/*] ) )\n      .) # no star unlike its friends in arg/vararg"
            }
        ], 
        "function": [
            {
                "include": "function-pointer"
            }, 
            {
                "include": "function-declaration"
            }, 
            {
                "include": "function-definition"
            }, 
            {
                "include": "function-call-macro"
            }, 
            {
                "include": "function-call"
            }
        ], 
        "ppline-directive-invalid-usage": [
            {
                "scope": "meta.preprocessor.directive.c", 
                "captures": {
                    "1": "keyword.other.preprocessor.c", 
                    "4": "invalid.illegal.invalid-usage-of-preprocessor-directive.c"
                }, 
                "match": "(^\\s*(#)\\s*(if|ifdef|ifndef|elif|pragma|define|undef|include|include_next|import)\\b)\\s*?(\\n|$)"
            }, 
            {
                "scope": "meta.preprocessor.directive.c", 
                "captures": {
                    "1": "keyword.other.preprocessor.c", 
                    "4": "invalid.illegal.invalid-usage-of-preprocessor-directive.c"
                }, 
                "match": "(^\\s*(#)\\s*(operator|accessor|replace|alias|align|incbin)\\b)\\s*?(\\n|$)"
            }
        ], 
        "string-format-specifier": [
            {
                "scope": "constant.other.placeholder.c", 
                "match": "(?x)%\n  (\\d+\\$)?                             # field (argument #)\n  [#0\\- +']*                           # flags\n  [,;:_]?                              # separator character (AltiVec)\n  ((-?\\d+)|\\*(-?\\d+\\$)?)?              # minimum field width\n  (\\.((-?\\d+)|\\*(-?\\d+\\$)?)?)?         # precision\n  (hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)? # length modifier\n  [diouxXDOUeEfFgGaACcSspn%bBqkKm]     # conversion type (the last ones: \"bBqkKm\" are ++C additions)"
            }, 
            {
                "scope": "invalid.illegal.placeholder.c", 
                "match": "%"
            }
        ], 
        "lex-operator": [
            {
                "scope": "punctuation.accessor.c", 
                "match": "(\\.|->)(?=(?:\\s|/\\*.*?\\*/)*+[A-Za-z_]\\w*+)"
            }, 
            {
                "scope": "keyword.operator.assignment.c", 
                "match": "(\\-|\\+|\\*|\\/|%|&|\\||\\^|<<|>>)?="
            }, 
            {
                "scope": "keyword.operator.comparison.c", 
                "match": "(==|!=|<=|>=|<>|<|>)"
            }, 
            {
                "scope": "keyword.operator.decrement.c", 
                "match": "(\\-\\-)"
            }, 
            {
                "scope": "keyword.operator.increment.c", 
                "match": "(\\+\\+)"
            }, 
            {
                "scope": "keyword.operator.ternary.c", 
                "match": "(\\?|:)"
            }, 
            {
                "scope": "keyword.operator.arithmetic.c", 
                "match": "(\\-|\\+|\\*|\\/|%)"
            }, 
            {
                "scope": "keyword.operator.logical.c", 
                "match": "(!|&&|\\|\\|)"
            }, 
            {
                "scope": "keyword.operator.bitwise.c", 
                "match": "(~|&|\\||\\^|<<|>>)"
            }, 
            {
                "scope": "keyword.operator.variadic.c", 
                "match": "(\\.\\.\\.)"
            }, 
            {
                "captures": {
                    "1": "keyword.operator.word.c"
                }, 
                "match": "\\s*\\b(compl|not|not_eq|and|and_eq|or|or_eq|xor|xor_eq|bitand|bitor)\\b"
            }, 
            {
                "captures": {
                    "1": "keyword.operator.word.c"
                }, 
                "match": "\\s*\\b(sizeof|defined)\\b"
            }, 
            {
                "captures": {
                    "1": "keyword.operator.word.c"
                }, 
                "match": "\\s*\\b(_Alignof|__alignof|__alignof__|__typeof|__typeof__)\\b"
            }, 
            {
                "captures": {
                    "1": "keyword.operator.word.++c"
                }, 
                "match": "\\s*\\b(alignof|typeof|nameof)\\b"
            }, 
            {
                "captures": {
                    "1": "keyword.operator.custom.++c"
                }, 
                "match": "\\s*\\b([\\=\\-\\+\\*\\/\\%\\&\\|\\^\\!\\~\\?\\:\\<\\>\\$\\@])\\b"
            }, 
            {
                "scope": "keyword.operator.getvalue.++c", 
                "match": "(\\*|\\$)(?=[A-Za-z_]\\w*)"
            }, 
            {
                "scope": "keyword.operator.getaddress.++c", 
                "match": "(\\&|\\@)(?=[A-Za-z_]\\w*)"
            }
        ], 
        "ppline-directive-obsolete": [
            {
                "captures": {
                    "1": "keyword.other.preprocessor.c", 
                    "2": "invalid.deprecated.preprocessor.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.preprocessor.directive.deprecated.c"
                    }, 
                    {
                        "match": "(?<=$\\n)(?<!\\\\$\\n)", 
                        "pop": true
                    }, 
                    {
                        "include": "lex-core"
                    }
                ], 
                "match": "^\\s*(#)\\s*(assert|unassert|ident|sccs)\\b"
            }
        ], 
        "function-declaration": [
            {
                "captures": {
                    "1": "entity.name.function.declaration.c"
                }, 
                "push": [
                    {
                        "meta_scope": "meta.function.declaration.c"
                    }, 
                    {
                        "include": "lex"
                    }, 
                    {
                        "include": "parens"
                    }, 
                    {
                        "scope": "punctuation.terminator.c", 
                        "match": "(;)", 
                        "pop": true
                    }
                ], 
                "match": "(?x)\n  (?: (?<! (?<!\\w) new\n        | (?<!\\w) (?:else|enum)\n        | (?<!\\w) (?:class|union)\n        | (?<!\\w) (?:struct|return|sizeof|typeof)\n        | (?<!\\w) __typeof | (?<!\\w) __typeof__\n      )\n      (?<= \\w\\b)\n    | #  or type modifier / closing bracket before name\n      (?<= [*>)}\\]] )\n  )\n  \\s*+\n  (   (?: [A-Za-z_]\\w*+ | ::[^:] | \\. )++ )\n  (?=\n    (?:\\s|/\\*.*?\\*/)*+\n    (?'parens' \\(\n      (?> \\g'parens'\n        | \"(\\\\.|[^\"])*\"\n        | '(\\\\.|[^'])*'\n        | /\\*.*?\\*/\n        | (?! /[/*] | [()] ) .\n      )*\n      \\)\n    )\n    \\s*;\n  )"
            }
        ]
    }, 
    "first_line_match": "-[*]-( Mode:)? C -[*]-", 
    "file_extensions": [
        "c", 
        "h", 
        "C", 
        "H", 
        "++c", 
        "++h", 
        "++C", 
        "++H", 
        "ppc", 
        "pph", 
        "ppC", 
        "ppH", 
        "PPc", 
        "PPh", 
        "PPC", 
        "PPH", 
        "xxc", 
        "xxh", 
        "xxC", 
        "xxH", 
        "XXc", 
        "XXh", 
        "XXC", 
        "XXH"
    ], 
    "name": "++C"
}