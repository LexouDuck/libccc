%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: ++C

comment: |
  https://github.com/abusalimov/SublimeCImproved
  https://github.com/lexouduck/libccc
    This is the ++C syntax coloring regex/lex rules, in sublime-syntax format
    which is derived from CImproved.tmLanguage - the Sublime Text syntax definition plugin package,
    which is derived from C.tmLanguage - the original TextMate and Sublime Text syntax definition.

file_extensions:
  - c
  - h
  - ++c
  - ++h
  - ppc
  - pph
  - xxc
  - xxh

first_line_match: "-[*]-( Mode:)? C -[*]-"

scope: source.c

contexts:

  main:
    - include: translation_unit

  translation_unit:
    - include: block-special
    - include: typedef
    - include: lex-type
    - include: lex
    - include: support
    - include: function
    - include: block
    - include: parens



  block-special:
    - match: |-
        (?x)
          (?= \s*
            (?:
                (?: \b extern \b
                    (?: "(\\.|[^"])*" | '(\\.|[^'])*' | /\*.*?\*/ | \s)*
                )
                |
                (?: \b namespace \b
                    (?: (?: /\*.*?\*/ | \s)* \b [A-Za-z_]\w*+ \b)?
                    (?: /\*.*?\*/ | \s)*
                )
            )
            \{
          )
      push:
        - match: '\}'
          pop: true
        - include: lex
        - match: '\{'
          push:
            - meta_scope: meta.block.special.c
            - match: '(?=\})'
              pop: true
            - include: $top_level_main



  block:
    - match: '(?=\{)'
      push:
        - match: '\}'
          pop: true
        - include: block-lookahead-end

  block-lookahead-end:
    - match: '\{'
      push:
        - meta_scope: meta.block.c
        - match: '(?=\})'
          pop: true
        - include: typedef
        - include: lex-type
        - include: lex
        - include: support
        - include: function
        - include: variable-declaration
        - include: macro
        - include: variable
        - include: ppline-macro-operator
        - include: $top_level_main



  parens:
    - match: (?=\()
      push:
        - match: \)
          pop: true
        - include: parens-lookahead-end

  parens-lookahead-end:
    - match: \(
      push:
        - meta_scope: meta.parens.c
        - match: (?=\))
          pop: true
        - include: lex-type
        - include: lex-core
        - include: support
        - include: function-pointer
        - include: function-call-macro
        - include: function-call
        - include: variable-declaration
        - include: macro
        - include: variable
        - include: ppline-macro-operator
        - include: $top_level_main



  lex:
    - include: lex-core
    - include: preprocessor

  lex-core:
    - include: lex-comment
    - include: lex-access
    - include: lex-continuation
    - include: lex-newline
    - include: lex-literal-number
    - include: lex-literal-string
    - include: lex-literal-string-format
    - include: lex-literal-string-regexp
    - include: lex-keyword
    - include: lex-storage
    - include: lex-operator
    - include: lex-constant

  lex-preprocessor:
    - include: lex-comment
    - include: lex-continuation
    - include: lex-newline

  lex-keyword:
    - match: \s*\b(break|case|continue|default|do|else|for|goto|if|return|switch|typedef|while)\b
      captures:
        1: keyword.control.c
    - match: \s*\b((__)?(asm|fortran|extension)(__)?)\b
      captures:
        1: keyword.control.extension.c
    - match: \s*\b(_Pragma)\b
      captures:
        1: keyword.control.C99.c
    - match: \s*\b(foreach)\b
      captures:
        1: keyword.control.++c

  lex-storage:
    - match: \s*\b(__attribute__)\b
      captures:
        1: storage.modifier.attribute.c
    - match: \s*\b(__declspec)\b
      captures:
        1: storage.modifier.declspec.c
    - match: \s*\b(auto|const|extern|register|static|volatile)\b
      captures:
        1: storage.modifier.c
    - match: \s*\b((__)?(inline|restrict)(__)?)\b
      captures:
        1: storage.modifier.C99.c
    - match: \s*\b(_Atomic|_Noreturn|noreturn|_Thread_local|thread_local)\b
      captures:
        1: storage.modifier.C11.c

    - match: \s*\b(bool|char|double|float|int|long|short|signed|unsigned|void)\b
      captures:
        1: storage.type.c
    - match: \s*\b(signed|unsigned)\b
      captures:
        1: storage.type.sign.c
    - match: \s*\b(enum|struct|union)\b\s+([_a-zA-Z0-9]\w*)
      captures:
        1: keyword.declaration.tag.c
        2: support.type.user.c
    - match: \s*\b(enum|struct|union)\b
      captures:
        1: keyword.declaration.anonymous.c
    - match: \s*\b(class)\b
      captures:
        1: keyword.declaration.c++

  lex-operator:
    - match: '(\.|->)(?=(?:\s|/\*.*?\*/)*+[A-Za-z_]\w*+)'
      scope: punctuation.accessor.c
    - match: (\-|\+|\*|\/|%|&|\||\^|<<|>>)?=
      scope: keyword.operator.assignment.c
    - match: (==|!=|<=|>=|<>|<|>)
      scope: keyword.operator.comparison.c
    - match: (\-\-)
      scope: keyword.operator.decrement.c
    - match: (\+\+)
      scope: keyword.operator.increment.c
    - match: (\?|:)
      scope: keyword.operator.ternary.c
    - match: (\-|\+|\*|\/|%)
      scope: keyword.operator.arithmetic.c
    - match: (!|&&|\|\|)
      scope: keyword.operator.logical.c
    - match: (~|&|\||\^|<<|>>)
      scope: keyword.operator.bitwise.c
    - match: (\.\.\.)
      scope: keyword.operator.variadic.c
    - match: \s*\b(compl|not|not_eq|and|and_eq|or|or_eq|xor|xor_eq|bitand|bitor)\b
      captures:
        1: keyword.operator.word.c
    - match: \s*\b(sizeof|offsetof|defined)\b
      captures:
        1: keyword.operator.word.c
    - match: \s*\b(_Alignas|alignas|alignof|_Alignof|_Generic|_Static_assert|static_assert)\b
      captures:
        1: keyword.operator.word.C11.c
    - match: \s*\b((__)?(typeof)(__)?)\b
      captures:
        1: keyword.operator.extension.c
    - match: (#)(?=\()
      scope: keyword.operator.constexpr.c
    - match: (\*|\$)(?=[A-Za-z_]\w*)
      scope: keyword.operator.getvalue.++c
    - match: (\&|\@)(?=[A-Za-z_]\w*)
      scope: keyword.operator.getaddress.++c
    - match: \b(is)\b
      scope: keyword.operator.equaltype.++c
    - match: \s*\b(=>)\b
      scope: keyword.operator.function.++c
    - match: \s*\b([\=\-\+\*\/\%\&\|\^\!\~\?\:\<\>\$\@]+)\b
      captures:
        1: keyword.operator.custom.++c

  lex-newline:
    - match: $\n
      scope: punctuation.whitespace.newline.c

  lex-continuation:
    - match: (\\)$(\n?)
      scope: punctuation.separator.continuation.c
      captures:
        1: keyword.other.line-continuation.c
        2: punctuation.whitespace.newline.c
    - match: \\(\s+?)(?=\n)$
      captures:
        1: invalid.deprecated.space-after-continuation.c

  lex-access:
    - match: '(?:(?<=\.)|(?<=->))\b([A-Za-z_]\w*+)\b(?!(?:\s|/\*.*?\*/)*+\()'
      scope: variable.other.member-access.c

  lex-constant:
    - match: \s*\b(NULL|TRUE|FALSE|NAN|NOTNUMBER|INF|INFINITY)\b
      captures:
        1: constant.language.c
    - match: \s*\b(null|true|false|ERROR|OK)\b
      captures:
        1: constant.language.++c

  lex-literal-number:
    - match: |-
        (?ix)  # hexadecimal float literal
          (?<!\.) \b

          (0x)

          # significand
          (?: (\.) (?=p)  # invalid
            |        [0-9a-f]*+ ([0-9a-z]*?) [0-9a-f]*+
              (?: \. [0-9a-f]*+ ([0-9a-z.]*?) [0-9a-f]*+ )? )

          # exponent (required)
          (?: (p) (?:        [+\-]  [0-9]++ ([0-9a-z]*?)
                    | (?=[0-9a-z.]) [0-9]*+ ([0-9a-z.]*?) )
            | (p) )

          # remaining valid chars and type specifier suffix
          [0-9]*+ ([fl]?)

          \b (?!\.)

      scope: constant.numeric.float.hexadecimal.c
      captures:
        1: constant.numeric.other.prefix.c
        2: invalid.illegal.number.missing-fragment.significand.c
        3: invalid.illegal.numeric-literal-character.float.whole-number.c
        4: invalid.illegal.numeric-literal-character.float.fraction.c
        5: keyword.other.exponent.hexadecimal.c
        6: invalid.illegal.numeric-literal-character.float.exponent.c
        7: invalid.illegal.numeric-literal-character.float.exponent.c
        8: invalid.illegal.number.missing-fragment.exponent.c
        9: constant.numeric.other.suffix.c
    - match: |-
        (?ix)  # hexadecimal float literal, without required exponent
          (?<!\.) \b

          (0x)

          # significand (at least a period)
               [0-9a-f]*+ ([0-9a-z&&[^p]]*?) [0-9a-f]*+
          (\.) [0-9a-f]*+ ([0-9a-z.&&[^p]]*?) [0-9a-f]*+

          # type specifier suffix
          (l?)

          (?:(?<=\.)|\b) (?!\.)

      scope: constant.numeric.float.hexadecimal.c
      captures:
        1: constant.numeric.other.prefix.c
        2: invalid.illegal.numeric-literal-character.float.whole-number.c
        3: invalid.illegal.number.hexadecimal-float-requires-exponent.c
        4: invalid.illegal.numeric-literal-character.float.fraction.c
        5: constant.numeric.other.suffix.c
    - match: |-
        (?ix)  # decimal float literal
          (?<!\.) (?:(?=\.)|\b)

          (?!0x)
          # significand
          (?: (?: [0-9]++ ([0-9a-z&&[^e]]*?) [0-9]*+ )?
              \.  [0-9]++ ([0-9a-z.&&[^e]]*?) [0-9]*+

            |     [0-9]++ ([0-9a-z&&[^e]]*?) [0-9]*+ (?: \. | (?=e)) )

          # exponent (optional)
          (?: (e) (?: [+\-]  [0-9]++ ([0-9a-z]*?)
                    |        [0-9]++ ([0-9a-z.]*?) )
            | ( p     [+\-]? [0-9]++
              | [ep]                  [0-9a-z.]*?) )?

          # any invalid chars and type specifier suffix
          ([0-9a-z]*?) [0-9]*+ ([fl]?)

          (?:(?<=\.)|\b) (?!\.)

      scope: constant.numeric.float.c
      captures:
        1: invalid.illegal.numeric-literal-character.float.whole-number.c
        2: invalid.illegal.numeric-literal-character.float.fraction.c
        3: invalid.illegal.numeric-literal-character.float.whole-number.c
        4: keyword.other.exponent.decimal.c
        5: invalid.illegal.numeric-literal-character.float.exponent.c
        6: invalid.illegal.numeric-literal-character.float.exponent.c
        7: invalid.illegal.numeric-literal-character.float.exponent.c
        8: invalid.illegal.numeric-literal-character.float.exponent.c
        9: constant.numeric.other.suffix.c
    - match: |-
        (?ix) # zero
          (?<!\.)
          \b
          (0[xbo])?           # literal prefix
          0++                 # iterate over number characters
          (u?l{0,2}|lul?|llu) # type specifier suffix, if any
          \b
          (?!\.)
      scope: constant.numeric.integer.zero.c
      captures:
        1: constant.numeric.other.prefix.c
        2: constant.numeric.other.suffix.c
    - match: |-
        (?ix) # invalid (empty) number literal
          (?<!\.)
          \b
          (?: (0x) | (0b) )   # literal prefix
          (u?l{0,2}|lul?|llu) # type specifier suffix, if any
          \b
          (?!\.)
      scope: invalid.illegal.invalid-number-literal.c
    - match: |-
        (?ix) # hexadecimal integer literal
          (?<!\.)
          \b
          (0x)                # literal prefix
          [0-9a-f]++          # iterate over number characters
          ([0-9a-z]*?)        # find any invalid chars
          [0-9a-f]*           # the remainder (after invalid chars, if any)
          (u?l{0,2}|lul?|llu) # type specifier suffix, if any
          \b
          (?!\.)
      scope: constant.numeric.integer.hexadecimal.c
      captures:
        1: constant.numeric.other.prefix.c
        2: invalid.illegal.numeric-literal-character.integer.c
        3: constant.numeric.other.suffix.c
    - match: |-
        (?ix) # binary integer literal
          (?<!\.)
          \b
          (0b)                # literal prefix
          [01]++              # iterate over number characters
          ([0-9a-z]*?)        # find any invalid chars
          [01]*               # the remainder (after invalid chars, if any)
          (u?l{0,2}|lul?|llu) # type specifier suffix, if any
          \b
          (?!\.)
      scope: constant.numeric.integer.binary.c
      captures:
        1: constant.numeric.other.prefix.c
        2: invalid.illegal.numeric-literal-character.integer.c
        3: constant.numeric.other.suffix.c
    - match: |-
        (?ix) # octal integer literal
          (?<!\.)
          \b
          (0|0o)              # literal prefix
          [0-7]++             # iterate over number characters
          ([0-9a-z]*?)        # find any invalid chars
          [0-7]*              # the remainder (after invalid chars, if any)
          (u?l{0,2}|lul?|llu) # type specifier suffix, if any
          \b
          (?!\.)
      scope: constant.numeric.integer.octal.c
      captures:
        1: constant.numeric.other.prefix.c
        2: invalid.illegal.numeric-literal-character.integer.c
        3: constant.numeric.other.suffix.c
    - match: |-
        (?ix) # decimal integer literal
          (?<!\.)
          \b
          [0-9]++             # iterate over number characters
          ([0-9a-z]*?)        # find any invalid chars
          [0-9]*              # the remainder (after invalid chars, if any)
          (u?l{0,2}|lul?|llu) # type specifier suffix, if any
          \b
          (?!\.)
      scope: constant.numeric.integer.decimal.c
      captures:
        1: invalid.illegal.numeric-literal-character.integer.c
        2: constant.numeric.other.suffix.c



  lex-literal-string:
    - match: "'"
      captures:
        0: punctuation.definition.string.begin.c
      push:
        - meta_scope: string.quoted.single.c
        - match: '('')|(?<=^|[^\\])\s*(\n)'
          captures:
            1: punctuation.definition.string.end.c
            2: invalid.illegal.unexpected-end-of-line.c
          pop: true
        - include: lex-continuation
        - include: string-escape-sequence
    - match: '(L|u8|u|U)?(")'
      captures:
        1: string.prefix.c
        2: punctuation.definition.string.begin.c
      push:
        - meta_scope: string.quoted.double.c
        - match: '(")|(?<=^|[^\\])\s*(\n)'
          captures:
            1: punctuation.definition.string.end.c
            2: invalid.illegal.unexpected-end-of-line.c
          pop: true
        - include: lex-continuation
        - include: string-escape-sequence
        - include: string-format-specifier
    - match: '(w|utf8|utf16|utf32)?(")'
      captures:
        1: string.prefix.++c
        2: punctuation.definition.string.begin.++c
      push:
        - meta_scope: string.quoted.double.c
        - match: '(")|(?<=^|[^\\])\s*(\n)'
          captures:
            1: punctuation.definition.string.end.++c
            2: invalid.illegal.unexpected-end-of-line.++c
          pop: true
        - include: lex-continuation
        - include: string-escape-sequence
        - include: string-format-specifier

  string-escape-sequence:
    - match: '\\(\\|[abefnprtv''"?]|[0-3]\d{,2}|[4-7]\d?|x[a-fA-F0-9]{,2}|u[a-fA-F0-9]{,4}|U[a-fA-F0-9]{,8})'
      scope: constant.character.escape.c
    - match: \\.
      scope: invalid.illegal.unknown-escape.c

  string-format-specifier:
    - match: |-
        (?x)%
          (\d+\$)?                             # field (argument #)
          [#0\- +']*                           # flags
          [,;:_]?                              # separator character (AltiVec)
          ((-?\d+)|\*(-?\d+\$)?)?              # minimum field width
          (\.((-?\d+)|\*(-?\d+\$)?)?)?         # precision
          (hh|h|ll|l|j|t|z|q|L|vh|vl|v|hv|hl)? # length modifier
          [diouxXDOUeEfFgGaACcSspn%bBqkKm]     # conversion type (the last ones: "bBqkKm" are ++C additions)
      scope: constant.other.placeholder.c
    - match: "%"
      scope: invalid.illegal.placeholder.c



  lex-literal-string-format:
    - match: '(f)?(")'
      captures:
        1: string.prefix.format.++c
        2: punctuation.other.string.begin.++c
      push:
        - meta_scope: string.format.++c
        - match: '(?<=[^\\])(#)\s*(?={)'
          captures:
            1: keyword.other.literal-string-format.expression.++c
            2: punctuation.other.format.expression.begin.++c
          push:
            - meta_scope: string.format.expression.++c
            - match: '(})'
              captures:
                1: punctuation.other.format.expression.end.++c
              pop: true
            - include: block-lookahead-end
        - match: '(")|(?<=^|[^\\])\s*(\n)'
          captures:
            1: punctuation.definition.string.end.++c
            2: invalid.illegal.unexpected-end-of-line.++c
          pop: true
        - match: \\#
          scope: constant.character.escape.++c
        - include: lex-continuation
        - include: string-escape-sequence
        - include: string-format-specifier



  lex-literal-string-regexp:
    - match: (?<!\+\+|--|})(?<=[=(:,\[?+!]|^return|[^\._$[:alnum:]]return|^case|[^\._$[:alnum:]]case|=>|&&|\|\||\*\/)\s*(r)(")(?![\/*])(?=(?:[^\/\\\[\()]|\\.|\[([^\]\\]|\\.)+\]|\(([^\)\\]|\\.)+\))+\"([gimsuy]+|(?![\/\*])|(?=\/\*))(?!\s*[a-zA-Z0-9_$]))
      captures:
        1: string.prefix.regexp.++c
        2: punctuation.definition.string.begin.++c
      push:
        - meta_scope: string.regexp.++c
        - match: (\")([gimsuy]*)
          captures:
            1: punctuation.definition.string.end.++c
            2: string.suffix.regexp.++c
          pop: true
        - include: regexp
    - match: ((?<![_$[:alnum:])\]]|\+\+|--|}|\*\/)|((?<=^return|[^\._$[:alnum:]]return|^case|[^\._$[:alnum:]]case))\s*)(r)(")(?![\/*])(?=(?:[^\/\\\[]|\\.|\[([^\]\\]|\\.)+\])+\"([gimsuy]+|(?![\/\*])|(?=\/\*))(?!\s*[a-zA-Z0-9_$]))
      captures:
        3: string.prefix.regexp.++c
        4: punctuation.definition.string.begin.++c
      push:
        - meta_scope: string.regexp.++c
        - match: (\")([gimsuy]*)
          captures:
            1: punctuation.definition.string.end.++c
            2: string.suffix.regexp.++c
          pop: true
        - include: regexp



  typedef:
    - match: (?x) (?<= \A typedef | \W typedef ) \b
      push:
        - meta_scope: meta.typedef.c
        - match: (;)
          scope: punctuation.other.terminator.c
          pop: true
        - include: lex
        - include: type-definition
        - include: block
        - match: '\s*\b([A-Za-z_]\w*+)(?=\s*[\[;])'
          captures:
            1: entity.name.type.typedef.c
        - include: support-type




  lex-type:
    - include: type-declaration
    - include: type-definition

  type-declaration:
    - match: |-
        (?x)
          (?<=  \A enum | \A (?:class|union) | \A struct |
                \W enum | \W (?:class|union) | \W struct )
          \b
          (?= (?:\s|/\*.*?\*/)*+
              ([A-Za-z_]\w*+)
              (?:\s|/\*.*?\*/)*+;
          )
      push:
        - meta_scope: meta.compound.c
        - match: (?<=;)
          pop: true
        - include: lex
        - match: '\s*\b([A-Za-z_]\w*+)\b'
          captures:
            1: entity.name.type.declaration.c

  type-definition:
    - match: |-
        (?x)
          (?<=  \A enum | \A (?:class|union) | \A struct |
                \W enum | \W (?:class|union) | \W struct )
          \b
          # Negation of zero-length parts of the end pattern
          # to prevent entering the rule if it's gonna exit immediately.
          # (workaround ST2 bugs, see issue #10)
          (?=\s*(?:[A-Za-z_({]|/[/*]|$))
          (?! \s*\b(?: [A-Za-z_]\w*+ ) (?= \s* [\[;] ) )

      push:
        - meta_scope: meta.compound.c
        - match: |-
            (?x)
              (?: (?!\s*(?:[A-Za-z_({]|/[/*]|$))
                | (?= \s*\b(?: [A-Za-z_]\w*+ ) (?= \s* [\[;] ) )
                | (?<!\})(?=
                      # Prefer function definition over an attribute defined
                      # through a macro, unless a block has been seen. That is:
                      #   struct __packed __aligned(16) foo {...}; - function __aligned
                      #   struct foo {...} __packed __aligned(16); - structure foo
                      (?! \s* \b__attribute__\b )

                      (?: ^
                        | (?<! (?<!\w) new
                              | (?<!\w) (?:else|enum)
                              | (?<!\w) (?:class|union)
                              | (?<!\w) (?:struct|return|sizeof|typeof)
                              | (?<!\w) __sizeof|__typeof
                              | (?<!\w) __sizeof__|__typeof__
                          )
                          (?<= \w ) \s

                        | #  or type modifier / closing bracket before name
                          (?<= [^ >-]> | [^(]\* | [}\]] )
                      )
                      \s*
                      (?: [A-Za-z_]\w*+ | ::[^:] | \. )++
                      (?: (?<= ^ operator | \W operator )  # C++ operator?
                          (?: [-*&<>=+!]+ | \(\) | \[\] ) )?
                      (?:\s|/\*.*?\*/)*+ \( ) )

          pop: true
        - match: '(?<=\})'
          push:
            - match: '(?!\s*(?:[A-Za-z_({]|/[/*]|$))'
              pop: true
            - include: lex
            - include: block
            - include: parens
        - include: lex
        - include: block
        - include: parens
        - match: '\b([A-Za-z_]\w*+)(?=(?:\s|/\*.*?\*/)*+(?:\{|(//.*)?\\?$))'
          captures:
            1: entity.name.type.class.c entity.name.class.c



  macro:
    - match: \b(__VA_ARGS__)\b
      captures:
        1: variable.language.c
    - match: \b(__\w++(?:__)?)\b
      captures:
        1: variable.other.constant.c
    - match: \b([_A-Z][_A-Z0-9]++)\b
      captures:
        1: variable.other.constant.c



  variable:
    - match: \b([A-Za-z_]\w*+)\b
      captures:
        1: variable.other.c

  variable-declaration:
    - match: |-
        (?x)
          (?: (?<! (?<!\w) new
                | (?<!\w) (?:else|enum)
                | (?<!\w) (?:class|union)
                | (?<!\w) (?:struct|return|sizeof|typeof)
                | (?<!\w) __typeof | (?<!\w) __typeof__
              )
              (?<= \w\b)
            | #  or type modifier / closing bracket before name
              (?<= [^ >-]> | [^(]\* | [}\]] )
          )
          \s*+
          (   (?: [A-Za-z_]\w*+ | ::[^:] )++ )
          (?=
            (?:\s|/\*.*?\*/)*+
            [=;,\)\[]
          )
      captures:
        1: entity.name.variable.declaration.c



  function:
    - include: function-pointer
    - include: function-declaration
    - include: function-definition
    - include: function-call-macro
    - include: function-call

  function-pointer:
    - match: (?<=\()(?:\s*\*\s*)([A-Za-z_]\w*+)(?:\s*\)\s*\()(;)
      captures:
        1: entity.name.variable.c
        2: punctuation.terminator.c

  function-declaration:
    - match: |-
        (?x)
          (?: (?<! (?<!\w) new
                | (?<!\w) (?:else|enum)
                | (?<!\w) (?:class|union)
                | (?<!\w) (?:struct|return|sizeof|typeof)
                | (?<!\w) __typeof
                | (?<!\w) __typeof__
              )
              (?<= \w\b)
            | #  or type modifier / closing bracket before name
              (?<= [^ >-]> | [^(]\* | [}\]] )
          )
          \s*+
          (   (?: [A-Za-z_]\w*+ | ::[^:] | \. )++ )
          (?=
            (?:\s|/\*.*?\*/)*+
            (?'parens' \(
              (?> \g'parens'
                | "(\\.|[^"])*"
                | '(\\.|[^'])*'
                | /\*.*?\*/
                | (?! /[/*] | [()] ) .
              )*
              \)
            )
            \s*;
          )
      captures:
        1: entity.name.function.declaration.c
      push:
        - meta_scope: meta.function.declaration.c
        - include: lex
        - include: parens
        - match: (;)
          scope: punctuation.terminator.c
          pop: true

  function-definition:
    - match: |-
        (?x)
          (?: (?<! (?<!\w) new
                | (?<!\w) (?:else|enum)
                | (?<!\w) (?:class|union)
                | (?<!\w) (?:struct|return|sizeof|typeof)
                | (?<!\w) __typeof
                | (?<!\w) __typeof__
              )
              (?<= \w\b)
            | #  or type modifier / closing bracket before name
              (?<= [^ >-]> | [^(]\* | [}\]] )
          )
          \s*+
          (   (?: [A-Za-z_]\w*+ | ::[^:] | \. )++ )
          (?=
            (?:\s|/\*.*?\*/)*+
            \(
          )
      captures:
        1: entity.name.function.definition.c
      push:
        - meta_scope: meta.function.definition.c
        - match: (\}|;)
          pop: true
        - include: lex
        - include: parens
        - include: block-lookahead-end
        - match: \s*\b(const|override)\b
          scope: storage.modifier.c

  function-call:
    - match: |-
        (?x)
          \s*\b
          (?= # don't consume string, to recognize support functions
              (?: [A-Za-z_]\w*+ | ::[^:] | \. )++
              (?: \s|/\*.*?\*/)*+
              \(
          )
      push:
        - meta_scope: meta.function-call.c
        - match: \)
          pop: true
        - include: lex
        - include: support-function
        - match: '(?:(?<=\.)|(?<=->))\b([A-Za-z_]\w*+)\b'
          scope: variable.function.access.c
        - match: '\b(?:([A-Za-z_]\w*+)|(::[^:]|\.|->))++\b'
          captures:
            1: variable.function.c
            2: punctuation.accessor.c
        - include: parens-lookahead-end

  function-call-macro:
    - match: |-
        (?x)
          \s*\b
          (?= # don't consume string, to recognize support functions
            (?: (?:[_A-Z][_A-Z0-9]*+)(?:\#\#)?)*+
            (?: \s|/\*.*?\*/)*+
            \(
          )
      push:
        - meta_scope: meta.function-call.constant.c
        - match: \)
          pop: true
        - include: lex
        - include: support-macro
        - match: '\b(\#\#)\b'
          captures:
            1: keyword.other.preprocessor.tokenpaste.c
        - match: '\b([_A-Z][_A-Z0-9]*+)\b'
          captures:
            1: variable.function.constant.c
        - include: parens-lookahead-end



  preprocessor:
    - match: (?=^\s*(#))
      push:
        - match: (?!^\s*(#))
          pop: true
        - include: preprocessor-disabled
        - include: ppline-directive-invalid-usage
        - include: ppline-macro
        - include: ppline-def
        - include: ppline-pragma-mark
        - include: ppline-include
        - include: ppline-plusplusc
        - include: ppline-directive
        - include: ppline-directive-obsolete
        - include: ppline-invalid
        - include: ppline-any

  preprocessor-disabled:
    - match: '^\s*(#)(?=\s*(if)\b(?=(?:\s|/\*.*?\*/)*+(0[xX])?0++\b(?:\s|/\*.*?\*/)*+(//.*)?\\?$))'
      captures:
        0: meta.preprocessor.directive.c keyword.other.preprocessor.c
      push:
        - match: (?=^\s*(#)\s*(endif|else|elif)\b)
          pop: true
        - match: ^
          push:
            - meta_scope: comment.other.preprocessor-disabled.c
            - match: $\n?
              pop: true
            - include: preprocessor-disabled-conditional
            - include: preprocessor-disabled-directive
        - match: '(?<!##)(?<=#)\s*(if)\b(?=(?:\s|/\*.*?\*/)*+(0[xX])?0++\b(?:\s|/\*.*?\*/)*+(//.*)?\\?$)'
          captures:
            1: keyword.other.preprocessor.define.c
          push:
            - meta_scope: meta.preprocessor.directive.c
            - match: (?<=$\n)(?<!\\$\n)
              pop: true
            - include: lex-core

  preprocessor-disabled-conditional:
    - match: ^\s*(#)\s*if(n?def)?\b
      push:
        - match: ^\s*(#)\s*endif\b.*$\n?
          pop: true
        - include: preprocessor-disabled-conditional
        - include: preprocessor-disabled-directive

  preprocessor-disabled-directive:
    - match: ^\s*(#)
      push:
        - match: (?<=$\n)(?<!\\$\n)
          pop: true


  ppline-plusplusc:
    - match: ^\s*(#)\s*(has|type|interface|namespace|operator|accessor)\b
      captures:
        0: keyword.other.preprocessor.++c
      push:
        - meta_scope: meta.preprocessor.directive.++c
        - match: (?<=$\n)(?<!\\$\n)
          pop: true
        - include: lex-core
        - include: support
        - include: function
        - include: block
        - include: parens


  ppline-macro:
    - match: '^\s*(#)(?=\s*(define)\s+[A-Za-z_]\w*+)'
      captures:
        0: keyword.other.preprocessor.c
      push:
        - meta_scope: meta.preprocessor.macro.c
        - match: (?<=$\n)(?<!\\$\n)
          pop: true
        - include: ppline-macro-head-function
        - include: ppline-macro-head-object
        - include: lex-core
        - include: ppline-macro-operator
        - include: support
        - include: function
        - include: block
        - include: parens
        - include: macro

  ppline-macro-operator:
        - match: '\s*(##)'
          captures:
            1: keyword.other.preprocessor.c
        - match: '\s*(#)\s*([A-Za-z_]\w*+)'
          captures:
            1: keyword.other.preprocessor.c
            2: string.macro.stringify.c

  ppline-macro-head-function:
    - match: '(?<!##)(?<=#)(\s*define)\s+([A-Za-z_]\w*+)(\()'
      captures:
        1: keyword.other.preprocessor.define.c
        2: entity.name.function.preprocessor.c
        3: meta.preprocessor.macro.parameters.c
      push:
        - meta_content_scope: meta.preprocessor.macro.parameters.c
        - match: '(?<=\))|(?<=^|[^\\])\s*(\n)'
          captures:
            1: invalid.illegal.unexpected-end-of-line.c
          pop: true
        - match: \)
        - match: '\b([A-Za-z_]\w*+)\b'
          captures:
            1: variable.parameter.c
          push:
            - match: '(?<=\))|(?=(?<=^|[^\\])\s*(\n))'
              pop: true
            - match: \)
            - include: ppline-macro-param-next
            - include: ppline-macro-param-vararg
            - include: ppline-macro-param-lex
            - include: ppline-macro-param-lex-invalid
        - include: ppline-macro-param-vararg
        - include: ppline-macro-param-lex
        - include: ppline-macro-param-lex-invalid

  ppline-macro-head-object:
    - match: '(?<!##)(?<=#)(\s*define)\s+([A-Za-z_]\w*+)(?!\()[\s&&[^\n]]*'
      captures:
        1: keyword.other.preprocessor.define.c
        2: entity.name.constant.preprocessor.c

  ppline-macro-param-lex:
    - match: \s*
    - match: \s*//
      captures:
        0: punctuation.definition.comment.c
      push:
        - meta_scope: invalid.illegal.unexpected-end-of-line.c
        - match: '(?<=^|[^\\])\s*(?=\n)$'
          pop: true
        - include: lex-continuation
    - include: lex-preprocessor

  ppline-macro-param-lex-invalid:
    - match: |-
        (?x)
          (?: (?! (?:\s|/\*.*?\*/)*+
                  (?: \) | (?>(?:\\\s*)?$\n?) | /[/*] ) )
              .) # no star unlike its friends in arg/vararg
      scope: invalid.illegal.unexpected-character.c

  ppline-macro-param-next:
    - match: (,)
      captures:
        1: punctuation.separator.parameter.c
      push:
        - match: '\b([A-Za-z_]\w*+)\b|(?=\.\.\.)|(\))|(?=(?<=^|[^\\])\s*(\n))'
          captures:
            1: variable.parameter.c
            2: invalid.illegal.unexpected-closing-paren.c
          pop: true
        - include: ppline-macro-param-lex
        - match: |-
            (?x)
              (?: (?! (?:\s|/\*.*?\*/)*+
                    (?: \b([A-Za-z_]\w*+)\b | \.\.\. | \) | (?>(?:\\\s*)?$\n?) | /[/*] ) )
                  .)*
          scope: invalid.illegal.unexpected-character.c

  ppline-macro-param-vararg:
    - match: (\.\.\.)
      captures:
        1: punctuation.definition.ellipsis.c
      push:
        - match: '(\))|(?=(?<=^|[^\\])\s*(\n))'
          pop: true
        - include: ppline-macro-param-lex
        - match: |-
            (?x)
              (?: (?! (?:\s|/\*.*?\*/)*+
                    (?: \) | (?>(?:\\\s*)?$\n?) | /[/*] ) )
                  .)*
          scope: invalid.illegal.unexpected-character.c

  ppline-def:
    - match: '(^\s*(#)\s*(ifdef|ifndef|undef))\s+([A-Za-z_]\w*+)'
      captures:
        1: keyword.other.preprocessor.c
        4: variable.other.constant.def.c
      push:
        - meta_scope: meta.preprocessor.def.c
        - match: (?<=$\n)(?<!\\$\n)
          pop: true
        - include: ppline-include-innards

  ppline-pragma-mark:
    - match: '(^\s*(#)\s*(pragma\s+mark)\b)[\s&&[^\n]]*'
      captures:
        1: keyword.other.preprocessor.pragma.c
      push:
        - meta_scope: meta.preprocessor.directive.pragma-mark.c
        - meta_content_scope: meta.toc-list.pragma-mark.c
        - match: (?<=$\n)(?<!\\$\n)
          pop: true
        - include: lex-preprocessor
        - match: .
          scope: string.other.pragma-mark.c

  ppline-include:
    - match: ^\s*(#)\s*(include|include_next|import)\b
      captures:
        0: keyword.other.preprocessor.include.c
      push:
        - meta_scope: meta.preprocessor.include.c meta.preprocessor.c.include
        - match: '(?:("[^"]*?)|(<[^>]*?))(\n)|(?<=$\n)(?<!\\$\n)'
          captures:
            1: string.quoted.double.include.c
            2: string.quoted.other.lt-gt.include.c
            3: invalid.illegal.unexpected-end-of-line.c
          pop: true
        - include: ppline-include-innards

  ppline-include-innards:
    - include: lex-preprocessor
    - match: '"|(?=.*?")'
      captures:
        0: punctuation.definition.string.begin.c
      push:
        - meta_scope: string.quoted.double.include.c
        - match: '"|(?<=^|[^\\])(?=\s*\n)'
          captures:
            0: punctuation.definition.string.end.c
          pop: true
    - match: <(?=.*?>)
      captures:
        0: punctuation.definition.string.begin.c
      push:
        - meta_scope: string.quoted.other.lt-gt.include.c
        - match: '>|(?<=^|[^\\])(?=\s*\n)'
          captures:
            0: punctuation.definition.string.end.c
          pop: true
    - match: \(
      push:
        - meta_scope: meta.parens.c
        - match: '\)|(?<=^|[^\\])(?=\s*\n)'
          pop: true
        - include: ppline-include-innards

  ppline-directive:
    - match: ^\s*(#)\s*(if|elif|else|endif|pragma|line|define|ifdef|ifndef|undef|error|warning)\b
      captures:
        0: keyword.other.preprocessor.c
      push:
        - meta_scope: meta.preprocessor.directive.c
        - match: (?<=$\n)(?<!\\$\n)
          pop: true
        - include: lex-core
        - include: macro
    - match: ^\s*(#)\s*(namespace|header|operator|accessor|reflect|incbin|is)\b
      captures:
        0: keyword.other.preprocessor.++c
      push:
        - meta_scope: meta.preprocessor.directive.++c
        - match: (?<=$\n)(?<!\\$\n)
          pop: true
        - include: lex-core
    - match: ^\s*(#)\s*(replace)\b
      captures:
        0: keyword.other.preprocessor.include.c
      push:
        - meta_scope: meta.preprocessor.include.c meta.preprocessor.c.include
        - match: '(?:("[^"]*?)|(<[^>]*?))(\n)|(?<=$\n)(?<!\\$\n)'
          captures:
            1: string.quoted.double.include.c
            2: string.quoted.other.lt-gt.include.c
            3: invalid.illegal.unexpected-end-of-line.c
          pop: true
        - include: ppline-include-innards

  ppline-directive-invalid-usage:
    - match: (^\s*(#)\s*(if|elif|pragma|define|ifdef|ifndef|undef|include|include_next|import)\b)\s*?(\n|$)
      scope: meta.preprocessor.directive.c
      captures:
        1: keyword.other.preprocessor.c
        4: invalid.illegal.invalid-usage-of-preprocessor-directive.c
    - match: (^\s*(#)\s*(operator|accessor|replace|incbin|is)\b)\s*?(\n|$)
      scope: meta.preprocessor.directive.c
      captures:
        1: keyword.other.preprocessor.c
        4: invalid.illegal.invalid-usage-of-preprocessor-directive.c

  ppline-directive-obsolete:
    - match: ^\s*(#)\s*(assert|unassert|ident|sccs)\b
      captures:
        1: keyword.other.preprocessor.c
        2: invalid.deprecated.preprocessor.c
      push:
        - meta_scope: meta.preprocessor.directive.deprecated.c
        - match: (?<=$\n)(?<!\\$\n)
          pop: true
        - include: lex-core

  ppline-any:
    - match: ^\s*(#)
      captures:
        0: keyword.other.preprocessor.c
      push:
        - meta_scope: meta.preprocessor.directive.null-directive.c
        - match: (?<=$\n)(?<!\\$\n)
          pop: true
        - include: lex-core

  ppline-invalid:
    - match: '^\s*(#)(?!\s*(?=/[/*]|(?>\\\s*\n)|\n|$))\s*(\w*)'
      captures:
        1: keyword.other.preprocessor.c
        2: invalid.illegal.preprocessor.c
      push:
        - meta_scope: meta.preprocessor.directive.illegal.c
        - match: (?<=$\n)(?<!\\$\n)
          pop: true



  support:
    - include: support-type
    - include: support-macro
    - include: support-function

  support-type:
    - match: \s*\b(u_char|u_short|u_int|u_long|(?:u_quad|quad|qaddr|caddr|daddr|dev|fixpt|blkcnt|blksize|gid|in_addr|in_port|ino|key|mode|nlink|id|pid|off|segsz|swblk|uid|id|siginfo)_t)\b
      captures:
        1: support.type.stdlib.c
    - match: \s*\b((size|ssize|rsize|ptrdiff)_t)\b
      captures:
        1: support.type.stddef.c
    - match: \s*\b(u?int(?:(?:_least|_fast)?(?:8|16|32|64)_t|ptr_t|max_t))\b
      captures:
        1: support.type.stdint.c
    - match: \s*\b(jmp_buf)\b
      captures:
        1: support.type.stdlib.c
    - match: \s*\b(va_list)\b
      captures:
        1: support.type.stdarg.c
    - match: \s*\b((time|time64|clock|useconds|suseconds|)_t)\b
      captures:
        1: support.type.time.c
    - match: \s*\b(_Bool|_Complex|_Imaginary)\b
      captures:
        1: support.type.C99.c
    - match: \s*\b(((w(int|char|ctype|ctrans))|(char(16|32))|mbstate|max_align)_t)\b
      captures:
        1: support.type.C11.c
    - match: \s*\b(_Decimal(32|64|128))\b
      captures:
        1: support.type.C23.c

    - match: \s*\b([tseufpi]_\w+)\b # TODO more restrictive category here, to potentially differntiate system types from user types ?
      captures:
        1: support.type.libccc.++c
    - match: \s*\b(T)\b
      captures:
        1: support.type.generic.++c

    - match: \s*\b(pthread_(?:t|attr_t|once_t|key_t|(?:cond|mutex|rwlock)(?:attr)?_t))\b
      captures:
        1: support.type.pthread.c
    - match: \s*\b(uv_\w+_t)\b
      captures:
        1: support.type.libuv.c
    - match: \s*\b((SDL_([A-Z][a-z]+)\w+(?!\()))\b
      captures:
        1: support.type.SDL2.c
    - match: \s*\b(napi_(status|extended_error_info|env|value|threadsafe_function|threadsafe_function_release_mode|threadsafe_function_call_mode|handle_scope|escapable_handle_scope|ref|type_tag|async_cleanup_hook_handle|callback_info|callback|finalize|async_execute_callback|async_complete_callback|threadsafe_function_call_js|async_cleanup_hook))\b
      captures:
        1: support.type.NAPI.c

  support-function:
    - match: \s*\b(hypot(f|l)?|s(scanf|ystem|nprintf|ca(nf|lb(n(f|l)?|ln(f|l)?))|i(n(h(f|l)?|f|l)?|gn(al|bit))|tr(s(tr|pn)|nc(py|at|mp)|c(spn|hr|oll|py|at|mp)|to(imax|d|u(l(l)?|max)|k|f|l(d|l)?)|error|pbrk|ftime|len|rchr|xfrm)|printf|et(jmp|vbuf|locale|buf)|qrt(f|l)?|w(scanf|printf)|rand)|n(e(arbyint(f|l)?|xt(toward(f|l)?|after(f|l)?))|an(f|l)?)|c(s(in(h(f|l)?|f|l)?|qrt(f|l)?)|cos(h(f)?|f|l)?|imag(f|l)?|t(ime|an(h(f|l)?|f|l)?)|o(s(h(f|l)?|f|l)?|nj(f|l)?|pysign(f|l)?)|p(ow(f|l)?|roj(f|l)?)|e(il(f|l)?|xp(f|l)?)|l(o(ck|g(f|l)?)|earerr)|a(sin(h(f|l)?|f|l)?|cos(h(f|l)?|f|l)?|tan(h(f|l)?|f|l)?|lloc|rg(f|l)?|bs(f|l)?)|real(f|l)?|brt(f|l)?)|t(ime|o(upper|lower)|an(h(f|l)?|f|l)?|runc(f|l)?|gamma(f|l)?|mp(nam|file))|i(s(space|n(ormal|an)|cntrl|inf|digit|u(nordered|pper)|p(unct|rint)|finite|w(space|c(ntrl|type)|digit|upper|p(unct|rint)|lower|al(num|pha)|graph|xdigit|blank)|l(ower|ess(equal|greater)?)|al(num|pha)|gr(eater(equal)?|aph)|xdigit|blank)|logb(f|l)?|max(div|abs))|di(v|fftime)|_Exit|unget(c|wc)|p(ow(f|l)?|ut(s|c(har)?|wc(har)?)|error|rintf)|e(rf(c(f|l)?|f|l)?|x(it|p(2(f|l)?|f|l|m1(f|l)?)?))|v(s(scanf|nprintf|canf|printf|w(scanf|printf))|printf|f(scanf|printf|w(scanf|printf))|w(scanf|printf)|a_(start|copy|end|arg))|qsort|f(s(canf|e(tpos|ek))|close|tell|open|dim(f|l)?|p(classify|ut(s|c|w(s|c))|rintf)|e(holdexcept|set(e(nv|xceptflag)|round)|clearexcept|testexcept|of|updateenv|r(aiseexcept|ror)|get(e(nv|xceptflag)|round))|flush|w(scanf|ide|printf|rite)|loor(f|l)?|abs(f|l)?|get(s|c|pos|w(s|c))|re(open|e|ad|xp(f|l)?)|m(in(f|l)?|od(f|l)?|a(f|l|x(f|l)?)?))|l(d(iv|exp(f|l)?)|o(ngjmp|cal(time|econv)|g(1(p(f|l)?|0(f|l)?)|2(f|l)?|f|l|b(f|l)?)?)|abs|l(div|abs|r(int(f|l)?|ound(f|l)?))|r(int(f|l)?|ound(f|l)?)|gamma(f|l)?)|w(scanf|c(s(s(tr|pn)|nc(py|at|mp)|c(spn|hr|oll|py|at|mp)|to(imax|d|u(l(l)?|max)|k|f|l(d|l)?|mbs)|pbrk|ftime|len|r(chr|tombs)|xfrm)|to(b|mb)|rtomb)|printf|mem(set|c(hr|py|mp)|move))|a(s(sert|ctime|in(h(f|l)?|f|l)?)|cos(h(f|l)?|f|l)?|t(o(i|f|l(l)?)|exit|an(h(f|l)?|2(f|l)?|f|l)?)|b(s|ort))|g(et(s|c(har)?|env|wc(har)?)|mtime)|r(int(f|l)?|ound(f|l)?|e(name|alloc|wind|m(ove|quo(f|l)?|ainder(f|l)?))|a(nd|ise))|b(search|towc)|m(odf(f|l)?|em(set|c(hr|py|mp)|move)|ktime|alloc|b(s(init|towcs|rtowcs)|towc|len|r(towc|len))))\s*\(\b
      captures:
        1: support.function.C99.c
    - match: |-
        (?x)
          \s*\b
          (   Py_REFCNT | Py_TYPE | Py_SIZE
            | Py_X?(?:INC|DEC)REF | Py_CLEAR
            | _?Py(?:Object|Type|HeapType|Dict|Set|List|Tuple|Long|Exception|Err)_\w++ )
          \b
      captures:
        1: support.function.cpython.c

  support-macro:
    - match: \s*\b(__builtin_\w++)\b
      captures:
        1: support.function.constant.intrinsic.c
    - match: |-
        (?x)
          \s*\b
          (   (?:__)?(?:DECL(?:ARE)?|DEF(?:INE)?)_[A-Z0-9_]+
            | (?:__)?[A-Z_][A-Z0-9_]*_(?:DECL(?:ARE)?|DEF(?:INE)?)
            | EXPORT(?:_UNUSED)?(?:_PER_CPU)?_SYMBOL(?:_GPL(?:_FUTURE)?)?
            | MODULE_(?:INFO|ALIAS|LICENSE|AUTHOR|DESCRIPTION|DEVICE_TABLE|VERSION|FIRMWARE)
            | (?:__)?MODULE_PARM_(?:TYPE|DESC)
            | module_param(?:(?:_array)?(?:_named)?|_call)
            | (?:module|core|postcore|arch|subsys|fs|device|late)_param_cb
            | [HL]?LIST_HEAD
            | (?:_|__BIN|BIN|BUS|DRIVER|CLASS|DEVICE)_ATTR(?:_R[OW])? )
          \b
      captures:
        1: support.function.constant.linux-kernel.macro.c
    - match: |-
        (?x)
          \s*\b
          (   _(?:IRQL|Kernel)_\w+_
            | _Interlocked_operand_
            | _Dispatch_type_
            | _Flt_CompletionContext_Outptr_ )
          \b
      captures:
        1: support.function.constant.windows-sal2.annotation.c
    - match: |-
        (?x)
          \s*\b
          (   PyAPI_(?:FUNC|DATA)
            | PyMODINIT_FUNC
            | Py_LOCAL(?:_INLINE)?
            | PyDoc_(?:STR(?:VAR)?|VAR)
            | PyObject(?:_VAR)?_HEAD
            | _PyObject_HEAD_EXTRA
            | PyException_HEAD
            | Py(?:Var)?Object_HEAD_INIT
            | PyModuleDef_HEAD_INIT
            | Py_(RETURN)_(?:FALSE|TRUE|NONE|NOTIMPLEMENTED|NAN|INF) )
          \b
      captures:
        1: support.function.constant.cpython.macro.c
        2: keyword.control.c
    - match: '\s*\b(_Py_IDENTIFIER)\b\s*\(\s*([A-Za-z_]\w*+)\s*\)'
      captures:
        1: support.function.constant.cpython.macro.c
        2: string.support.cpython.identifier.c
    - match: '\s*\bPyId_([A-Za-z_]\w*+)\b'
      captures:
        1: string.support.cpython.identifier.c



  lex-comment:
    - match: '\s*(/\*)([*!])'
      captures:
        1: punctuation.definition.comment.block.documentation.c
        2: comment.command
      push:
        - meta_scope: comment.block.documentation.c
        - match: '(\*/)'
          pop: true
        - include: comment-documentation
    - match: '\s*(//)([/!]<?)'
      captures:
        1: punctuation.definition.comment.line.documentation.c
        2: comment.command
      push:
        - meta_scope: comment.line.documentation.c
        - match: '(?<=$\n)(?<!\\$\n)'
          pop: true
        - include: comment-documentation
        - include: lex-continuation

    - match: '\s*(/\*)'
      captures:
        1: punctuation.definition.comment.block.c
      push:
        - meta_scope: comment.block.c
        - match: '(\*/)'
          pop: true
        - include: comment
    - match: '\s*(//)'
      captures:
        1: punctuation.definition.comment.line.c
      push:
        - meta_scope: comment.line.++c
        - match: '(?<=$\n)(?<!\\$\n)'
          pop: true
        - include: comment
        - include: lex-continuation

    - match: '\*/(?![/*])'
      scope: invalid.illegal.stray-comment-end.c

  comment:
    - include: comment-note
    - include: comment-banner-line
    - include: lex-newline

  comment-documentation:
    - include: comment-note
    - include: comment-command
    - include: lex-newline

  comment-banner-line:
    - match: '(?:(?<=/[/\*])|^)[\s/*]*(=+\s*(.*?)\s*=+(?:(?=[\s/*+\-]*\*/)|$(\n?)))'
      captures:
        1: meta.toc-list.banner.c
        3: punctuation.whitespace.newline.c

  comment-note:
    - match: |-
        (?ix)
            (?= (?-i: \b [A-Z_]++) \b) @? \b
            ( TODO
            | NOTE
            | NB
            | TBD
            | REVIEW
            | CHANGED
            | IDEA
            | IMPORTANT
            | HACK
            | BUG
            | DEPRECATED
            ) \b
      captures:
        0: comment.command.c
        1: storage.type.class.note.c
      push:
        - meta_scope: meta.toc-list.task-tag.note.c
        - match: '(?=[\s/*]*\*/)|(?<=$\n)'
          pop: true

  comment-command:
    - match: '(`(.*?)`)'
      captures:
        0: markup.raw
    - match: '\b(#)(?:[A-Za-z_]\w+)\b'
      captures:
        0: comment.c
        1: comment.command.c
    - match: '\b(?:[A-Za-z_]\w+)(\(\))'
      captures:
        0: comment.c
        1: comment.command.c
    - match: '@[{}]'
      captures:
        0: comment.command.c
    - match: |-
        (?ix)
          (?= (?-i: [@\\][A-Za-z_]++) \b) [@\\]? \b
          ( GROUP
          | ALIAS
          | ARG
          | DOC
          | MINIDOC
          | FAMILY
          | SEEALSO
          | ISOSTD
          | NONSTD
          | ERRORS
          | PARAM_ENV
          | PARAM_WORKER
          | PARAM_RESULT
          | (?:END)?EXAMPLES
          | (?:END)?EXAMPLECODE
          ) \b
          ({([^}]*)})?
      captures:
        0: comment.command.c
        1: comment.command.user.c
        2: comment.command.c
        3: comment.command.user.c
    - match: |-
        (?ix)
          [@\\] \b
          (?:
            ( ({) | (})
            | ADDINDEX
            | ARG
            | ATTENTION
            | AUTHOR
            | AUTHORS
            | BRIEF
            | BUG
            | CALLERGRAPH
            | CALLGRAPH
            | CODE
            | COND
            | COPYRIGHT
            | DATE
            | DEPRECATED
            | DETAILS
            | DOCBOOKONLY
            | DOT
            | ELSE
            | ELSEIF
            | EMOJI
            | ENDCODE
            | ENDCOND
            | ENDDOCBOOKONLY
            | ENDDOT
            | ENDHTMLONLY
            | ENDIF
            | ENDINTERNAL
            | ENDLATEXONLY
            | ENDLINK
            | ENDMANONLY
            | ENDMSC
            | ENDPARBLOCK
            | ENDRTFONLY
            | ENDSECREFLIST
            | ENDVERBATIM
            | ENDUML
            | ENDXMLONLY
            | EXCEPTION
            | EXTENDS
            | FN
            | FILE
            | HIDECALLERGRAPH
            | HIDECALLGRAPH
            | HIDEREFBY
            | HIDEREFS
            | HIDEINITIALIZER
            | HTMLONLY
            | IF
            | IFNOT
            | IMAGE
            | INTERNAL
            | INVARIANT
            | LATEXONLY
            | LI
            | LINE
            | MAINPAGE
            | MANONLY
            | MSC
            | N
            | NAME
            | NOOP
            | NOSUBGROUPING
            | NOTE
            | OVERLOAD
            | PARBLOCK
            | POST
            | PRE
            | PRIVATE
            | PRIVATESECTION
            | PROPERTY
            | PROTECTED
            | PROTECTEDSECTION
            | PUBLIC
            | PUBLICSECTION
            | PURE
            | REMARK
            | REMARKS
            | RESULT
            | RETURN
            | RETURNS
            | RETVAL
            | RTFONLY
            | SA
            | SECREFLIST
            | SECTION
            | SEE
            | SHORT
            | SHOWINITIALIZER
            | SHOWREFBY
            | SHOWREFS
            | SINCE
            | SKIP
            | SKIPLINE
            | STATIC
            | STARTUML
            | TABLEOFCONTENTS
            | TEST
            | THROW
            | THROWS
            | TODO
            | TPARAM
            | UNTIL
            | VERBATIM
            | VERSION
            | VHDLFLOW
            | WARNING
            | XMLONLY
            | XREFITEM
            ) \b |
            ( F[\$\[\]\{\}]
            | \$
            | \@
            | \\
            | \&
            | \~
            | \<
            | \=
            | \>
            | \#
            | \%
            | \"
            | \.
            | \|
            | ::
            | --
            | ---
            )
          )
      captures:
        0: comment.command.c
        1: comment.command.doxygen.c
        2: comment.command.doxygen.group-brace.c
        3: comment.command.doxygen.group-close.c
        4: comment.command.doxygen.c
    - match: |-
        (?ix)
            [@\\] \b
            ( ({) | (})
            | A
            | ADDTOGROUP
            | ANCHOR
            | B
            | C
            | CATEGORY
            | CITE
            | CLASS
            | COPYBRIEF
            | COPYDETAILS
            | COPYDOC
            | DEF
            | DEFGROUP
            | DIAFILE
            | DIR
            | DOCBOOKINCLUDE
            | DONTINCLUDE
            | DOTFILE
            | E
            | EM
            | ENUM
            | EXAMPLE
            | FILE
            | HEADERFILE
            | HTMLINCLUDE
            | IDLEXCEPT
            | IMPLEMENTS
            | INCLUDE
            | INCLUDEDOC
            | INCLUDELINENO
            | INGROUP
            | INTERFACE
            | LATEXINCLUDE
            | LINK
            | MANINCLUDE
            | MEMBEROF
            | MSCFILE
            | NAMESPACE
            | P
            | PACKAGE
            | PAGE
            | PAR
            | PARAM
            | PARAGRAPH
            | PROTOCOL
            | REF
            | REFITEM
            | RELATED
            | RELATES
            | RELATEDALSO
            | RELATESALSO
            | RTFINCLUDE
            | SNIPPET
            | SNIPPETDOC
            | SNIPPETLINENO
            | STRUCT
            | SUBPAGE
            | SUBSECTION
            | SUBSUBSECTION
            | TYPEDEF
            | UNION
            | VAR
            | VERBINCLUDE
            | WEAKGROUP
            | XMLINCLUDE
            ) \b
            [\t\ ]*([^\s]+)
      captures:
        0: comment.command.c
        1: comment.command.doxygen.c
        2: comment.command.doxygen.group-brace.c
        3: comment.command.doxygen.group-close.c
        4: comment.command.user.c



  regex-character-class:
    - match: \\[wWsSdDtrnvf]|\.
      scope: constant.other.character-class.regexp
    - match: \\([0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4})
      scope: constant.character.numeric.regexp
    - match: \\c[A-Z]
      scope: constant.character.control.regexp
    - match: \\.
      scope: constant.character.escape.backslash.regexp

  regexp:
    - match: \\[bB]|\^|\$
      scope: keyword.control.anchor.regexp
    - match: \\[1-9]\d*|\\k<([a-zA-Z_$][\w$]*)>
      captures:
        0: keyword.other.back-reference.regexp
        1: variable.other.regexp
    - match: '[?+*]|\{(\d+,\d+|\d+,|,\d+|\d+)\}\??'
      scope: keyword.operator.quantifier.regexp
    - match: \|
      scope: keyword.operator.or.regexp
    - match: (\()((\?=)|(\?!)|(\?<=)|(\?<!))
      captures:
        1: punctuation.definition.group.regexp
        2: punctuation.definition.group.assertion.regexp
        3: meta.assertion.look-ahead.regexp
        4: meta.assertion.negative-look-ahead.regexp
        5: meta.assertion.look-behind.regexp
        6: meta.assertion.negative-look-behind.regexp
      push:
        - meta_scope: meta.group.assertion.regexp
        - match: (\))
          captures:
            1: punctuation.definition.group.regexp
          pop: true
        - include: regexp
    - match: \((?:(\?:)|(?:\?<([a-zA-Z_$][\w$]*)>))?
      captures:
        0: punctuation.definition.group.regexp
        1: punctuation.definition.group.no-capture.regexp
        2: variable.other.regexp
      push:
        - meta_scope: meta.group.regexp
        - match: \)
          captures:
            0: punctuation.definition.group.regexp
          pop: true
        - include: regexp
    - match: (\[)(\^)?
      captures:
        1: punctuation.definition.character-class.regexp
        2: keyword.operator.negation.regexp
      push:
        - meta_scope: constant.other.character-class.set.regexp
        - match: (\])
          captures:
            1: punctuation.definition.character-class.regexp
          pop: true
        - match: (?:.|(\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\c[A-Z])|(\\.))\-(?:[^\]\\]|(\\(?:[0-7]{3}|x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}))|(\\c[A-Z])|(\\.))
          scope: constant.other.character-class.range.regexp
          captures:
            1: constant.character.numeric.regexp
            2: constant.character.control.regexp
            3: constant.character.escape.backslash.regexp
            4: constant.character.numeric.regexp
            5: constant.character.control.regexp
            6: constant.character.escape.backslash.regexp
        - include: regex-character-class
    - include: regex-character-class
