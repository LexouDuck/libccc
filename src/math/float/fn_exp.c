
#include "libccc/float.h"
#include "libccc/math/float.h"
#include "libccc/math.h"

#include LIBCONFIG_ERROR_INCLUDE



#if LIBCONFIG_USE_STD_MATH
MATH_DECL_REALFUNCTION(Exp, exp)
#elif LIBCONFIG_USE_CCC_MATH
#define DEFINEFUNC_FLOAT_EXP(BITS) \
t_f##BITS		F##BITS##_Exp(t_f##BITS x) \
{ \
	if CCCERROR(IS_NAN(x), ERROR_NANARGUMENT, NULL) \
		return (NAN); \
	if (x < -10.) \
		return (0.); \
	t_f##BITS result = 1.; \
	result *= (x + 8.); \
	result *= (x + 56.); \
	result *= (x + 336.); \
	result *= (x + 1680.); \
	result *= (x + 6720.); \
	result *= (x + 20160.); \
	result *= (x + 40320.); \
	result *= (x + 40320.); \
	result *= 2.4801587301e-5; \
	return (result); \
} \

DEFINEFUNC_FLOAT_EXP(32)
DEFINEFUNC_FLOAT_EXP(64)
#if LIBCONFIG_USE_FLOAT80
DEFINEFUNC_FLOAT_EXP(80)
#endif
#if LIBCONFIG_USE_FLOAT128
DEFINEFUNC_FLOAT_EXP(128)
#endif

#if 0 // crazy fast approximate method TODO: fix infinite loop ??
	u_float_cast result = { x };

	result.value_int = (1512775 * result.value_int + 1072632447);
	result.value_int <<= (BITS / 2);
	return (result.value_float);
#endif

#if 0 // precise but slow iterative method
	t_f##BITS		result;
	t_f##BITS		result_prev;
	t_f##BITS		acc_x;
	t_f##BITS		acc_i;
	t_u32		i;

	if (x < 100.)
		return (0.);
	i = 1.;
	result = 1.;
	acc_x = 1.;
	acc_i = 1.;
	result_prev = 0.;
	while (ABS(result - result_prev) > FLOAT_APPROX)
	{
		result_prev = result;
		acc_x *= x;
		acc_i *= i;
		result += acc_x / acc_i;
		++i;
	}
	return (result);
#endif



#else



#ifdef __GNUC__
#define predict_true(x) __builtin_expect(!!(x), 1)
#define predict_false(x) __builtin_expect(x, 0)
#else
#define predict_true(x) (x)
#define predict_false(x) (x)
#endif
/* Support non-nearest rounding mode. */
#define WANT_ROUNDING 1
/* Support signaling NaNs. */
#define WANT_SNAN 0
/* apply SNaN config */
#if WANT_SNAN
#error SNaN is unsupported
#else
#define issignalingf_inline(x) 0
#define issignaling_inline(x) 0
#endif

static t_f32	__math_oflowf (t_f32 x)	{ return (x); }
static t_f32	__math_uflowf (t_f32 x)	{ return (x); }
static t_f64	__math_oflow  (t_f64 x)	{ return (x); }
static t_f64	__math_uflow  (t_f64 x)	{ return (x); }



#define EXP2F_TABLE_BITS	5
#define EXP2F_POLY_ORDER	3
#define N_F32	(1 << EXP2F_TABLE_BITS)
extern const struct expf_data
{
	t_f64	shift;
	t_f64	shift_scaled;
	t_f64	invln2_scaled;
	t_f64	poly[EXP2F_POLY_ORDER];
	t_f64	poly_scaled[EXP2F_POLY_ORDER];
	t_u64	table[N_F32];
}	__expf_data;

const struct expf_data __expf_data =
{
	/*
	table[i] = uint(2^(i/N)) - (i << 52-BITS)
	used for computing 2^(k/N) for an int |k| < 150 N as
	double(table[k%N] + (k << 52-BITS))
	*/
	.table = {
		0x3FF0000000000000,
		0x3FEFD9B0D3158574,
		0x3FEFB5586CF9890F,
		0x3FEF9301D0125B51,
		0x3FEF72B83C7D517B,
		0x3FEF54873168B9AA,
		0x3FEF387A6E756238,
		0x3FEF1E9DF51FDEE1,
		0x3FEF06FE0A31B715,
		0x3FEEF1A7373AA9CB,
		0x3FEEDEA64C123422,
		0x3FEECE086061892D,
		0x3FEEBFDAD5362A27,
		0x3FEEB42B569D4F82,
		0x3FEEAB07DD485429,
		0x3FEEA47EB03A5585,
		0x3FEEA09E667F3BCD,
		0x3FEE9F75E8EC5F74,
		0x3FEEA11473EB0187,
		0x3FEEA589994CCE13,
		0x3FEEACE5422AA0DB,
		0x3FEEB737B0CDC5E5,
		0x3FEEC49182A3F090,
		0x3FEED503B23E255D,
		0x3FEEE89F995AD3AD,
		0x3FEEFF76F2FB5E47,
		0x3FEF199BDD85529C,
		0x3FEF3720DCEF9069,
		0x3FEF5818DCFBA487,
		0x3FEF7C97337B9B5F,
		0x3FEFA4AFA2A490DA,
		0x3FEFD0765B6E4540,
	},
	.poly = {
		0x1.C6AF84B912394p-5,
		0x1.EBFCE50FAC4F3p-3,
		0x1.62E42FF0C52D6p-1,
	},
	.poly_scaled = {
		0x1.C6AF84B912394p-5/N_F32/N_F32/N_F32,
		0x1.EBFCE50FAC4F3p-3/N_F32/N_F32,
		0x1.62E42FF0C52D6p-1/N_F32,
	},
	.shift = 0x1.8p+52,
	.shift_scaled = 0x1.8p+52 / N_F32,
	.invln2_scaled = 0x1.71547652B82FEp+0 * N_F32,
};



#define EXP_TABLE_BITS	7
#define EXP_POLY_ORDER	5
#define EXP_USE_TOINT_NARROW	0
#define EXP2_POLY_ORDER	5
#define N_F64	(1 << EXP_TABLE_BITS)
extern const struct exp_data
{
	t_f64	shift;
	t_f64	invln2N;
	t_f64	negln2hiN;
	t_f64	negln2loN;
	t_f64	poly[4]; /* Last four coefficients. */
	t_f64	exp_shift;
	t_f64	exp_poly[EXP2_POLY_ORDER];
	t_u64	table[2*N_F64];
}	__exp_data;

const struct exp_data __exp_data =
{
	.invln2N   = +0x1.71547652B82FEp0 * N_F64, // N/ln2
	.negln2hiN = -0x1.62E42FEFA0000p-8, // -ln2/N (hi)
	.negln2loN = -0x1.CF79ABC9E3B3Ap-47, // -ln2/N (lo)
	// Used for rounding when !TOINT_INTRINSICS
	#if EXP_USE_TOINT_NARROW
	.shift = 0x1800000000.8p0,
	#else
	.shift = 0x1.8p52,
	#endif
	// exp polynomial coefficients.
	.poly = {
		// abs error: 1.555*2^-66
		// ulp error: 0.509 (0.511 without fma)
		// if |x| < ln2/256+eps
		// abs error if |x| < ln2/256+0x1p-15: 1.09*2^-65
		// abs error if |x| < ln2/128: 1.7145*2^-56
		0x1.FFFFFFFFFFDBDp-2,
		0x1.555555555543Cp-3,
		0x1.55555CF172B91p-5,
		0x1.1111167A4D017p-7,
	},
	.exp_shift = 0x1.8p52 / N_F64,
	// exp polynomial coefficients.
	.exp_poly = {
		// abs error: 1.2195*2^-65
		// ulp error: 0.507 (0.511 without fma)
		// if |x| < 1/256
		// abs error if |x| < 1/128: 1.9941*2^-56
		0x1.62E42FEFA39EFp-1,
		0x1.EBFBDFF82C424p-3,
		0x1.C6B08D70CF4B5p-5,
		0x1.3B2ABD24650CCp-7,
		0x1.5D7E09B4E3A84p-10,
	},
	.table = {
		// 2^(k/N) ~= H[k]*(1 + __exp_data.table[k]) for int k in [0,N)
		// table[2*k] = AS_U64(__exp_data.table[k])
		// table[2*k+1] = AS_U64(H[k]) - (k << 52)/N
		0x0000000000000000, 0x3FF0000000000000,
		0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,
		0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,
		0xBC905E7A108766D1, 0x3FEFE315E86E7F85,
		0x3C8CD2523567F613, 0x3FEFD9B0D3158574,
		0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,
		0x3C60F74E61E6C861, 0x3FEFC74518759BC8,
		0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,
		0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,
		0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,
		0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,
		0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,
		0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,
		0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,
		0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,
		0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,
		0xBC801B15EAA59348, 0x3FEF72B83C7D517B,
		0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,
		0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,
		0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,
		0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,
		0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,
		0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,
		0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,
		0x3C968EFDE3A8A894, 0x3FEF387A6E756238,
		0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,
		0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,
		0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,
		0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,
		0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,
		0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,
		0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,
		0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,
		0x3C864201E2AC744C, 0x3FEF0170FC4CD831,
		0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,
		0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,
		0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,
		0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,
		0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,
		0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,
		0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,
		0xBC9312607A28698A, 0x3FEEDA4504AC801C,
		0xBC58A78F4817895B, 0x3FEED60A21F72E2A,
		0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,
		0x3C4363ED60C2AC11, 0x3FEECE086061892D,
		0x3C9666093B0664EF, 0x3FEECA41ED1D0057,
		0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,
		0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,
		0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,
		0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,
		0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,
		0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,
		0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,
		0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,
		0x3C93350518FDD78E, 0x3FEEAF4736B527DA,
		0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,
		0x3C9063E1E21C5409, 0x3FEEAB07DD485429,
		0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,
		0x3C9432E62B64C035, 0x3FEEA76F15AD2148,
		0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,
		0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,
		0xBC845378892BE9AE, 0x3FEEA34634CCC320,
		0xBC93CEDD78565858, 0x3FEEA23882552225,
		0x3C5710AA807E1964, 0x3FEEA155D44CA973,
		0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,
		0xBC6A12AD8734B982, 0x3FEEA012750BDABF,
		0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,
		0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,
		0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,
		0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,
		0xBC8619321E55E68A, 0x3FEE9FEB564267C9,
		0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,
		0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,
		0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,
		0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,
		0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,
		0xBC9369B6F13B3734, 0x3FEEA589994CCE13,
		0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,
		0xBC94D450D872576E, 0x3FEEA8D99B4492ED,
		0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,
		0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,
		0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,
		0x3C7BF68359F35F44, 0x3FEEB1AE99157736,
		0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,
		0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,
		0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,
		0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,
		0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,
		0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,
		0x3C6DD235E10A73BB, 0x3FEEC86319E32323,
		0xBC87C50422622263, 0x3FEECC667B5DE565,
		0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,
		0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,
		0x3C90CC319CEE31D2, 0x3FEED99E1330B358,
		0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,
		0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,
		0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,
		0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,
		0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,
		0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,
		0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,
		0xBC91EEE26B588A35, 0x3FEF05B030A1064A,
		0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,
		0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,
		0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,
		0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,
		0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,
		0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,
		0x3C676B2C6C921968, 0x3FEF3720DCEF9069,
		0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,
		0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,
		0xBC900DAE3875A949, 0x3FEF4F87080D89F2,
		0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,
		0xBC82919E2040220F, 0x3FEF60E316C98398,
		0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,
		0x3C843A59AC016B4B, 0x3FEF7321F301B460,
		0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,
		0xBC892AB93B470DC9, 0x3FEF864614F5A129,
		0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,
		0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,
		0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,
		0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,
		0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,
		0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,
		0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,
		0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,
		0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,
		0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1,
	},
};

#if LIBCONFIG_USE_FLOAT80
#define EXP_TABLE_BITS	7
#define N_F80	(1 << EXP_TABLE_BITS)
extern const struct expl_data
{
	t_f64	redux;
	t_f64	poly[7];
	t_f64	table[2*N_F80];
}	__expl_data;

static const struct expl_data __expl_data =
{
	.redux = 0x1.8p63 / N_F80,
	.poly = {
		0x1.0p0,
		0x1.62E42FEFA39EFp-1,
		0x1.EBFBDFF82C58Fp-3,
		0x1.C6B08D7049FA0p-5,
		0x1.3B2AB6FBA4DA5p-7,
		0x1.5D8804780A736p-10,
		0x1.430918835E33Dp-13,
	},
	.table = {
		0x1.6A09E667F3BCDp-1,	-0x1.BDD3413B2648p-55,
		0x1.6C012750BDABFp-1,	-0x1.2895667FF0C0p-57,
		0x1.6DFB23C651A2Fp-1,	-0x1.BBE3A683C880p-58,
		0x1.6FF7DF9519484p-1,	-0x1.83C0F25860F0p-56,
		0x1.71F75E8EC5F74p-1,	-0x1.16E4786887B0p-56,
		0x1.73F9A48A58174p-1,	-0x1.0A8D96C65D50p-55,
		0x1.75FEB564267C9p-1,	-0x1.0245957316E0p-55,
		0x1.780694FDE5D3Fp-1,	+0x1.866B80A02160p-55,
		0x1.7A11473EB0187p-1,	-0x1.41577EE04990p-56,
		0x1.7C1ED0130C132p-1,	+0x1.F124CD1164E0p-55,
		0x1.7E2F336CF4E62p-1,	+0x1.05D02BA157A0p-57,
		0x1.80427543E1A12p-1,	-0x1.27C86626D970p-55,
		0x1.82589994CCE13p-1,	-0x1.D4C1DD415330p-55,
		0x1.8471A4623C7ADp-1,	-0x1.8D684A341CE0p-56,
		0x1.868D99B4492EDp-1,	-0x1.FC6F89BD4F68p-55,
		0x1.88AC7D98A6699p-1,	+0x1.994C2F37CB50p-55,
		0x1.8ACE5422AA0DBp-1,	+0x1.6E9F156864B0p-55,
		0x1.8CF3216B5448Cp-1,	-0x1.0D55E32E9E40p-57,
		0x1.8F1AE99157736p-1,	+0x1.5CC13A2E3970p-56,
		0x1.9145B0B91FFC6p-1,	-0x1.DD6792E58250p-55,
		0x1.93737B0CDC5E5p-1,	-0x1.75FC781B5800p-58,
		0x1.95A44CBC8520Fp-1,	-0x1.64B7C96A5F00p-57,
		0x1.97D829FDE4E50p-1,	-0x1.D185B7C1B860p-55,
		0x1.9A0F170CA07BAp-1,	-0x1.173BD91CEE60p-55,
		0x1.9C49182A3F090p-1,	+0x1.C7C46B071F20p-57,
		0x1.9E86319E32323p-1,	+0x1.824CA78E64C0p-57,
		0x1.A0C667B5DE565p-1,	-0x1.359495D1CD50p-55,
		0x1.A309BEC4A2D33p-1,	+0x1.6305C7DDC368p-55,
		0x1.A5503B23E255Dp-1,	-0x1.D2F6EDB8D420p-55,
		0x1.A799E1330B358p-1,	+0x1.BCB7ECAC5640p-55,
		0x1.A9E6B5579FDBFp-1,	+0x1.0FAC90EF7FD0p-55,
		0x1.AC36BBFD3F37Ap-1,	-0x1.F9234CAE76D0p-56,
		0x1.AE89F995AD3ADp-1,	+0x1.7A1CD345DCC8p-55,
		0x1.B0E07298DB666p-1,	-0x1.BDEF54C80E40p-55,
		0x1.B33A2B84F15FBp-1,	-0x1.2805E3084D80p-58,
		0x1.B59728DE5593Ap-1,	-0x1.C71DFBBBA6E0p-55,
		0x1.B7F76F2FB5E47p-1,	-0x1.5584F7E54AC0p-57,
		0x1.BA5B030A1064Ap-1,	-0x1.EFCD30E54290p-55,
		0x1.BCC1E904BC1D2p-1,	+0x1.23DD07A2D9F0p-56,
		0x1.BF2C25BD71E09p-1,	-0x1.EFDCA3F6B9C8p-55,
		0x1.C199BDD85529Cp-1,	+0x1.110658950490p-56,
		0x1.C40AB5FFFD07Ap-1,	+0x1.B4537E083C60p-55,
		0x1.C67F12E57D14Bp-1,	+0x1.2884DFF483C8p-55,
		0x1.C8F6D9406E7B5p-1,	+0x1.1ACBC48805C0p-57,
		0x1.CB720DCEF9069p-1,	+0x1.503CBD1E94A0p-57,
		0x1.CDF0B555DC3FAp-1,	-0x1.DD83B53829D0p-56,
		0x1.D072D4A07897Cp-1,	-0x1.CBC3743797A8p-55,
		0x1.D2F87080D89F2p-1,	-0x1.D487B719D858p-55,
		0x1.D5818DCFBA487p-1,	+0x1.2ED02D75B370p-56,
		0x1.D80E316C98398p-1,	-0x1.11EC18BEDE00p-55,
		0x1.DA9E603DB3285p-1,	+0x1.C2300696DB50p-55,
		0x1.DD321F301B460p-1,	+0x1.2DA5778F0190p-55,
		0x1.DFC97337B9B5Fp-1,	-0x1.1A5CD4F184B8p-55,
		0x1.E264614F5A129p-1,	-0x1.7B627817A148p-55,
		0x1.E502EE78B3FF6p-1,	+0x1.39E8980A9CD0p-56,
		0x1.E7A51FBC74C83p-1,	+0x1.2D522CA0C8E0p-55,
		0x1.EA4AFA2A490DAp-1,	-0x1.E9C23179C288p-55,
		0x1.ECF482D8E67F1p-1,	-0x1.C93F3B411AD8p-55,
		0x1.EFA1BEE615A27p-1,	+0x1.DC7F486A4B68p-55,
		0x1.F252B376BBA97p-1,	+0x1.3A1A5BF0D8E8p-55,
		0x1.F50765B6E4540p-1,	+0x1.9D3E12DD8A18p-55,
		0x1.F7BFDAD9CBE14p-1,	-0x1.DBB12D006350p-55,
		0x1.FA7C1819E90D8p-1,	+0x1.74853F3A5930p-56,
		0x1.FD3C22B8F71F1p-1,	+0x1.2EB749665780p-58,
		0x1p+0,                  0x0p+0,
		0x1.0163DA9FB3335p+0,	+0x1.B61299AB8CD8p-54,
		0x1.02C9A3E778061p+0,	-0x1.19083535B080p-56,
		0x1.04315E86E7F85p+0,	-0x1.0A31C1977C98p-54,
		0x1.059B0D3158574p+0,	+0x1.D73E2A475B40p-55,
		0x1.0706B29DDF6DEp+0,	-0x1.C91DFE2B13C0p-55,
		0x1.0874518759BC8p+0,	+0x1.186BE4BB2840p-57,
		0x1.09E3ECAC6F383p+0,	+0x1.148781831610p-54,
		0x1.0B5586CF9890Fp+0,	+0x1.8A62E4ADC610p-54,
		0x1.0CC922B7247F7p+0,	+0x1.01EDC16E24F8p-54,
		0x1.0E3EC32D3D1A2p+0,	+0x1.03A1727C5800p-59,
		0x1.0FB66AFFED31Bp+0,	-0x1.B9BEDC44EBC0p-57,
		0x1.11301D0125B51p+0,	-0x1.6C51039449B0p-54,
		0x1.12ABDC06C31CCp+0,	-0x1.1B514B36CA80p-58,
		0x1.1429AAEA92DE0p+0,	-0x1.32FBF9AF1368p-54,
		0x1.15A98C8A58E51p+0,	+0x1.2406AB9EEAB0p-55,
		0x1.172B83C7D517Bp+0,	-0x1.19041B9D78A0p-55,
		0x1.18AF9388C8DEAp+0,	-0x1.11023D1970F8p-54,
		0x1.1A35BEB6FCB75p+0,	+0x1.E5B4C7B49690p-55,
		0x1.1BBE084045CD4p+0,	-0x1.95386352EF60p-54,
		0x1.1D4873168B9AAp+0,	+0x1.E016E00A2640p-54,
		0x1.1ED5022FCD91Dp+0,	-0x1.1DF98027BB78p-54,
		0x1.2063B88628CD6p+0,	+0x1.DC775814A850p-55,
		0x1.21F49917DDC96p+0,	+0x1.2A97E9494A60p-55,
		0x1.2387A6E756238p+0,	+0x1.9B07EB6C7058p-54,
		0x1.251CE4FB2A63Fp+0,	+0x1.AC155BEF4F50p-55,
		0x1.26B4565E27CDDp+0,	+0x1.2BD339940EA0p-55,
		0x1.284DFE1F56381p+0,	-0x1.A4C3A8C3F0D8p-54,
		0x1.29E9DF51FDEE1p+0,	+0x1.612E8AFAD120p-55,
		0x1.2B87FD0DAD990p+0,	-0x1.10ADCD638200p-59,
		0x1.2D285A6E4030Bp+0,	+0x1.0024754DB420p-54,
		0x1.2ECAFA93E2F56p+0,	+0x1.1CA0F45D5240p-56,
		0x1.306FE0A31B715p+0,	+0x1.6F46AD231830p-55,
		0x1.32170FC4CD831p+0,	+0x1.A9CE78E18040p-55,
		0x1.33C08B26416FFp+0,	+0x1.327218436598p-54,
		0x1.356C55F929FF1p+0,	-0x1.B5CEE5C4E460p-55,
		0x1.371A7373AA9CBp+0,	-0x1.63AEABF42EB0p-54,
		0x1.38CAE6D05D866p+0,	-0x1.E958D3C99048p-54,
		0x1.3A7DB34E59FF7p+0,	-0x1.5E436D661F60p-56,
		0x1.3C32DC313A8E5p+0,	-0x1.EFFF8375D2A0p-54,
		0x1.3DEA64C123422p+0,	+0x1.ADA0911F09F0p-55,
		0x1.3FA4504AC801Cp+0,	-0x1.7D023F956FA0p-54,
		0x1.4160A21F72E2Ap+0,	-0x1.EF3691C30900p-58,
		0x1.431F5D950A897p+0,	-0x1.1C7DDE35F7A0p-55,
		0x1.44E086061892Dp+0,	+0x1.89B7A04EF800p-59,
		0x1.46A41ED1D0057p+0,	+0x1.C944BD1648A8p-54,
		0x1.486A2B5C13CD0p+0,	+0x1.3C1A3B690620p-56,
		0x1.4A32AF0D7D3DEp+0,	+0x1.9CB62F3D1BE8p-54,
		0x1.4BFDAD5362A27p+0,	+0x1.D4397AFEC420p-56,
		0x1.4DCB299FDDD0Dp+0,	+0x1.8ECDBBC6A780p-54,
		0x1.4F9B2769D2CA7p+0,	-0x1.4B309D259580p-54,
		0x1.516DAA2CF6642p+0,	-0x1.F768569BD940p-55,
		0x1.5342B569D4F82p+0,	-0x1.07ABE1DB13D0p-55,
		0x1.551A4CA5D920Fp+0,	-0x1.D689CEFEDE60p-55,
		0x1.56F4736B527DAp+0,	+0x1.9BB2C011D938p-54,
		0x1.58D12D497C7FDp+0,	+0x1.295E15B9A1E0p-55,
		0x1.5AB07DD485429p+0,	+0x1.6324C0546478p-54,
		0x1.5C9268A5946B7p+0,	+0x1.C4B1B8169800p-60,
		0x1.5E76F15AD2148p+0,	+0x1.BA6F93080E68p-54,
		0x1.605E1B976DC09p+0,	-0x1.3E2429B56DE8p-54,
		0x1.6247EB03A5585p+0,	-0x1.383C17E40B48p-54,
		0x1.6434634CCC320p+0,	-0x1.C483C759D890p-55,
		0x1.6623882552225p+0,	-0x1.BB60987591C0p-54,
		0x1.68155D44CA973p+0,	+0x1.038AE44F7400p-57,
	},
};
#endif


#if LIBCONFIG_USE_FLOAT128
#define EXP_TABLE_BITS	7
#define N_F128	(1 << EXP_TABLE_BITS)
extern const struct expl_data
{
	t_f64	redux;
	t_f128	poly[11];
	t_f128	table[N_F128];
	t_f32	eps[N_F128];
}	__expl_data;

static const struct expl_data __expl_data =
{
	.redux = 0x1.8p112 / N_F128,
	.poly =
	{
		0x1.0p0,
		0x1.62E42FEFA39EF35793C7673007E6p-1L,
		0x1.EBFBDFF82C58EA86F16B06EC9736p-3L,
		0x1.C6B08D704A0BF8B33A762BAD3459p-5L,
		0x1.3B2AB6FBA4E7729CCBBE0B4F3FC2p-7L,
		0x1.5D87FE78A67311071DEE13FD11D9p-10L,
		0x1.430912F86C7876F4B663B23C5FE5p-13L,
		0x1.FFCBFC588B041p-17,
		0x1.62C0223A5C7C7p-20,
		0x1.B52541FF59713p-24,
		0x1.E4CF56A391E22p-28,
	},
	.table =
	{
		0x1.6A09E667F3BCC908B2FB1366DFEAp-1L,
		0x1.6C012750BDABEED76A99800F4EDEp-1L,
		0x1.6DFB23C651A2EF220E2CBE1BC0D4p-1L,
		0x1.6FF7DF9519483CF87E1B4F3E1E98p-1L,
		0x1.71F75E8EC5F73DD2370F2EF0B148p-1L,
		0x1.73F9A48A58173BD5C9A4E68AB074p-1L,
		0x1.75FEB564267C8BF6E9AA33A489A8p-1L,
		0x1.780694FDE5D3F619AE02808592A4p-1L,
		0x1.7A11473EB0186D7D51023F6CCB1Ap-1L,
		0x1.7C1ED0130C1327C49334459378DEp-1L,
		0x1.7E2F336CF4E62105D02BA1579756p-1L,
		0x1.80427543E1A11B60DE67649A3842p-1L,
		0x1.82589994CCE128ACF88AFAB34928p-1L,
		0x1.8471A4623C7ACCE52F6B97C6444Cp-1L,
		0x1.868D99B4492EC80E41D90AC2556Ap-1L,
		0x1.88AC7D98A669966530BCDF2D4CC0p-1L,
		0x1.8ACE5422AA0DB5BA7C55A192C648p-1L,
		0x1.8CF3216B5448BEF2AA1CD161C57Ap-1L,
		0x1.8F1AE991577362B982745C72EDDAp-1L,
		0x1.9145B0B91FFC588A61B469F6B6A0p-1L,
		0x1.93737B0CDC5E4F4501C3F2540AE8p-1L,
		0x1.95A44CBC8520EE9B483695A0E7FEp-1L,
		0x1.97D829FDE4E4F8B9E920F91E8EB6p-1L,
		0x1.9A0F170CA07B9BA3109B8C467844p-1L,
		0x1.9C49182A3F0901C7C46B071F28DEp-1L,
		0x1.9E86319E323231824CA78E64C462p-1L,
		0x1.A0C667B5DE564B29ADA8B8CABBACp-1L,
		0x1.A309BEC4A2D3358C171F770DB1F4p-1L,
		0x1.A5503B23E255C8B424491CAF88CCp-1L,
		0x1.A799E1330B3586F2DFB2B158F31Ep-1L,
		0x1.A9E6B5579FDBF43EB243BDFF53A2p-1L,
		0x1.AC36BBFD3F379C0DB966A3126988p-1L,
		0x1.AE89F995AD3AD5E8734D17731C80p-1L,
		0x1.B0E07298DB66590842ACDFC6FB4Ep-1L,
		0x1.B33A2B84F15FAF6BFD0E7BD941B0p-1L,
		0x1.B59728DE559398E3881111648738p-1L,
		0x1.B7F76F2FB5E46EAA7B081AB53FF6p-1L,
		0x1.BA5B030A10649840CB3C6AF5B74Cp-1L,
		0x1.BCC1E904BC1D2247BA0F45B3D06Cp-1L,
		0x1.BF2C25BD71E088408D7025190CD0p-1L,
		0x1.C199BDD85529C2220CB12A0916BAp-1L,
		0x1.C40AB5FFFD07A6D14DF820F17DEAp-1L,
		0x1.C67F12E57D14B4A2137FD20F2A26p-1L,
		0x1.C8F6D9406E7B511ACBC48805C3F6p-1L,
		0x1.CB720DCEF90691503CBD1E949D0Ap-1L,
		0x1.CDF0B555DC3F9C44F8958FAC4F12p-1L,
		0x1.D072D4A07897B8D0F22F21A13792p-1L,
		0x1.D2F87080D89F18ADE123989EA50Ep-1L,
		0x1.D5818DCFBA48725DA05AEB66DFF8p-1L,
		0x1.D80E316C98397BB84F9D048807A0p-1L,
		0x1.DA9E603DB3285708C01A5B6D480Cp-1L,
		0x1.DD321F301B4604B695DE3C0630C0p-1L,
		0x1.DFC97337B9B5EB968CAC39ED284Cp-1L,
		0x1.E264614F5A128A12761FA17ADC74p-1L,
		0x1.E502EE78B3FF6273D130153992D0p-1L,
		0x1.E7A51FBC74C834B548B2832378A4p-1L,
		0x1.EA4AFA2A490D9858F73A18F5DAB4p-1L,
		0x1.ECF482D8E67F08DB0312FB949D50p-1L,
		0x1.EFA1BEE615A27771FD21A92DABB6p-1L,
		0x1.F252B376BBA974E8696FC3638F24p-1L,
		0x1.F50765B6E4540674F84B762861A6p-1L,
		0x1.F7BFDAD9CBE138913B4BFE72BD78p-1L,
		0x1.FA7C1819E90D82E90A7E74B26360p-1L,
		0x1.FD3C22B8F71F10975BA4B32BD006p-1L,
		0x1.0000000000000000000000000000p+0L,
		0x1.0163DA9FB33356D84A66AE336E98p+0L,
		0x1.02C9A3E778060EE6F7CACA4F7A18p+0L,
		0x1.04315E86E7F84BD738F9A20DA442p+0L,
		0x1.059B0D31585743AE7C548EB68C6Ap+0L,
		0x1.0706B29DDF6DDC6DC403A9D87B1Ep+0L,
		0x1.0874518759BC808C35F25D942856p+0L,
		0x1.09E3ECAC6F3834521E060C584D5Cp+0L,
		0x1.0B5586CF9890F6298B92B7184200p+0L,
		0x1.0CC922B7247F7407B705B893DBDEp+0L,
		0x1.0E3EC32D3D1A2020742E4F8AF794p+0L,
		0x1.0FB66AFFED31AF232091DD8A169Ep+0L,
		0x1.11301D0125B50A4EBBF1AED9321Cp+0L,
		0x1.12ABDC06C31CBFB92BAD324D6F84p+0L,
		0x1.1429AAEA92DDFB34101943B2588Ep+0L,
		0x1.15A98C8A58E512480D573DD562AEp+0L,
		0x1.172B83C7D517ADCDF7C8C50EB162p+0L,
		0x1.18AF9388C8DE9BBBF70B9A3C269Cp+0L,
		0x1.1A35BEB6FCB753CB698F692D2038p+0L,
		0x1.1BBE084045CD39AB1E72B442810Ep+0L,
		0x1.1D4873168B9AA7805B8028990BE8p+0L,
		0x1.1ED5022FCD91CB8819FF61121FBEp+0L,
		0x1.2063B88628CD63B8EEB0295093F6p+0L,
		0x1.21F49917DDC962552FD29294BC20p+0L,
		0x1.2387A6E75623866C1FADB1C159C0p+0L,
		0x1.251CE4FB2A63F3582AB7DE9E9562p+0L,
		0x1.26B4565E27CDD257A673281D3068p+0L,
		0x1.284DFE1F5638096CF15CF03C9FA0p+0L,
		0x1.29E9DF51FDEE12C25D15F5A25022p+0L,
		0x1.2B87FD0DAD98FFDDEA46538FCA24p+0L,
		0x1.2D285A6E4030B40091D536D0733Ep+0L,
		0x1.2ECAFA93E2F5611CA0F45D5239A4p+0L,
		0x1.306FE0A31B7152DE8D5A463063BEp+0L,
		0x1.32170FC4CD8313539CF1C3009330p+0L,
		0x1.33C08B26416FF4C9C8610D96680Ep+0L,
		0x1.356C55F929FF0C94623476373BE4p+0L,
		0x1.371A7373AA9CAA7145502F45452Ap+0L,
		0x1.38CAE6D05D86585A9CB0D9BED530p+0L,
		0x1.3A7DB34E59FF6EA1BC9299E0A1FEp+0L,
		0x1.3C32DC313A8E484001F228B58CF0p+0L,
		0x1.3DEA64C12342235B41223E13D7EEp+0L,
		0x1.3FA4504AC801BA0BF701AA417B9Cp+0L,
		0x1.4160A21F72E29F84325B8F3DBACAp+0L,
		0x1.431F5D950A896DC704439410B628p+0L,
		0x1.44E086061892D03136F409DF0724p+0L,
		0x1.46A41ED1D005772512F459229F0Ap+0L,
		0x1.486A2B5C13CD013C1A3B69062F26p+0L,
		0x1.4A32AF0D7D3DE672D8BCF46F99B4p+0L,
		0x1.4BFDAD5362A271D4397AFEC42E36p+0L,
		0x1.4DCB299FDDD0D63B36EF1A9E19DEp+0L,
		0x1.4F9B2769D2CA6AD33D8B69AA0B8Cp+0L,
		0x1.516DAA2CF6641C112F52C84D6066p+0L,
		0x1.5342B569D4F81DF0A83C49D86BF4p+0L,
		0x1.551A4CA5D920EC52EC620243540Cp+0L,
		0x1.56F4736B527DA66ECB004764E61Ep+0L,
		0x1.58D12D497C7FD252BC2B7343D554p+0L,
		0x1.5AB07DD48542958C93015191E9A8p+0L,
		0x1.5C9268A5946B701C4B1B81697ED4p+0L,
		0x1.5E76F15AD21486E9BE4C20399D12p+0L,
		0x1.605E1B976DC08B076F592A487066p+0L,
		0x1.6247EB03A5584B1F0FA06FD2D9EAp+0L,
		0x1.6434634CCC31FC76F8714C4EE122p+0L,
		0x1.66238825522249127D9E29B92EA2p+0L,
		0x1.68155D44CA973081C57227B9F69Ep+0L,
	}
	.eps =
	{
		-0x1.5C50p-101,
		-0x1.5D00p-106,
		+0x1.8E90p-102,
		-0x1.5340p-103,
		+0x1.1BD0p-102,
		-0x1.4600p-105,
		-0x1.7A40p-104,
		+0x1.D590p-102,
		-0x1.D590p-101,
		+0x1.B100p-103,
		-0x1.0D80p-105,
		+0x1.6B00p-103,
		-0x1.9F00p-105,
		+0x1.C400p-103,
		+0x1.E120p-103,
		-0x1.C100p-104,
		-0x1.9D20p-103,
		+0x1.A800p-108,
		+0x1.4C00p-106,
		-0x1.9500p-106,
		+0x1.6900p-105,
		-0x1.29D0p-100,
		+0x1.4C60p-103,
		+0x1.13A0p-102,
		-0x1.5B60p-103,
		-0x1.1C40p-103,
		+0x1.DB80p-102,
		+0x1.91A0p-102,
		+0x1.DC00p-105,
		+0x1.44C0p-104,
		+0x1.9710p-102,
		+0x1.8760p-103,
		-0x1.A720p-103,
		+0x1.ED20p-103,
		-0x1.49C0p-102,
		-0x1.E000p-111,
		+0x1.86A0p-103,
		+0x1.2B40p-103,
		-0x1.B400p-108,
		+0x1.1280p-099,
		-0x1.02D8p-102,
		-0x1.E3D0p-103,
		-0x1.B080p-105,
		-0x1.F100p-107,
		-0x1.16C0p-105,
		-0x1.1190p-103,
		-0x1.A7D2p-100,
		+0x1.3450p-103,
		-0x1.67C0p-105,
		+0x1.4B80p-104,
		-0x1.C4E0p-103,
		+0x1.6000p-108,
		-0x1.3F60p-105,
		+0x1.93F0p-104,
		+0x1.5FE0p-105,
		+0x1.6F80p-107,
		-0x1.7600p-106,
		+0x1.21E0p-106,
		-0x1.3A40p-106,
		-0x1.40C0p-104,
		-0x1.9860p-105,
		-0x1.5D40p-108,
		-0x1.1D70p-106,
		+0x1.2760p-105,
		 0x0.0000p+0,
		+0x1.21E2p-104,
		-0x1.9520p-108,
		-0x1.5720p-106,
		-0x1.4810p-106,
		-0x1.BE00p-109,
		+0x1.0080p-105,
		-0x1.5780p-108,
		-0x1.D460p-105,
		-0x1.6140p-105,
		+0x1.4630p-104,
		+0x1.AD50p-103,
		+0x1.82E0p-105,
		+0x1.1D3Cp-101,
		+0x1.6100p-107,
		+0x1.EC30p-104,
		+0x1.F200p-108,
		+0x1.0B40p-103,
		+0x1.3660p-102,
		+0x1.D9D0p-103,
		-0x1.02D0p-102,
		+0x1.B070p-103,
		+0x1.B9C0p-104,
		-0x1.01C0p-103,
		-0x1.DFE0p-103,
		+0x1.1B60p-104,
		-0x1.AE94p-101,
		-0x1.3340p-104,
		+0x1.B3D8p-102,
		-0x1.6E40p-105,
		-0x1.3670p-103,
		+0x1.C140p-104,
		+0x1.1840p-101,
		+0x1.1AB0p-102,
		-0x1.A400p-104,
		+0x1.1F00p-104,
		-0x1.7180p-103,
		+0x1.4CE0p-102,
		+0x1.9200p-107,
		-0x1.54C0p-103,
		+0x1.1B80p-105,
		-0x1.1828p-101,
		+0x1.5720p-102,
		-0x1.A060p-100,
		+0x1.9160p-102,
		+0x1.A280p-104,
		+0x1.3400p-107,
		+0x1.2B20p-102,
		+0x1.7800p-108,
		+0x1.CFD0p-101,
		+0x1.2EF0p-102,
		-0x1.2760p-099,
		+0x1.B380p-104,
		+0x1.0048p-101,
		-0x1.60B0p-102,
		+0x1.A1CCp-100,
		-0x1.A640p-104,
		-0x1.08A0p-101,
		+0x1.7E60p-102,
		+0x1.22C0p-103,
		-0x1.7200p-106,
		+0x1.F0F0p-102,
		+0x1.EB4Ep-099,
		+0x1.C6E0p-103,
	}
};
#endif



/* Top 12 bits of a double (sign and exponent bits). */
static inline t_u32 top12_f32(t_f64 x)
{
	return AS_U64(x) >> 52;
}

static inline t_u32 top12_f64(t_f32 x)
{
	return AS_U32(x) >> 20;
}

/*
**	Handle cases that may overflow or underflow when computing the result that is scale*(1+TMP) without intermediate rounding.
**	The bit representation of scale is in SBITS, however it has a computed exponent
**	that may have overflown into the sign bit so that needs to be adjusted before using it as a double.
**	(int32_t)KI is the k used in the argument reduction and exponent adjustment of scale,
**	positive k here means the result may overflow and negative k means the result may underflow.
*/
static
inline
t_f64	specialcase(t_f64 tmp, t_u64 sbits, t_u64 ki)
{
	t_f64 scale, y;

	if ((ki & 0x80000000) == 0)
	{
		/* k > 0, the exponent of scale might have overflowed by <= 460. */
		sbits -= 1009ull << 52;
		scale = AS_F64(sbits);
		y = 0x1p1009 * (scale + scale * tmp);
		return (y);
	}
	/* k < 0, need special care in the subnormal range. */
	sbits += 1022ull << 52;
	scale = AS_F64(sbits);
	y = scale + scale * tmp;
	if (y < 1.0)
	{
		/*
		Round y to the right precision before scaling it into the subnormal
		range to avoid double rounding that can cause 0.5+E/2 ulp error where
		E is the worst-case ulp error outside the subnormal range.  So this
		is only useful if the goal is better than 1 ulp worst-case error.
		*/
		t_f64 hi, lo;
		lo = scale - y + scale * tmp;
		hi = 1.0 + y;
		lo = 1.0 - hi + y + lo;
		y = (hi + lo) - 1.0;
		/* Avoid -0.0 with downward rounding. */
		if (WANT_ROUNDING && y == 0.0)
			y = 0.0;
		/* The underflow exception needs to be signaled explicitly. */
		/* fp_force_eval(fp_barrier(0x1p-1022) * 0x1p-1022); */
	}
	y = 0x1p-1022 * y;
	return (y);
}



t_f32	F32_Exp(t_f32 x)
{
	t_u32 abstop;
	t_u64 ki, t;
	t_f64 kd, xd, z, r, r2, y, s;
	/* Filter out exceptional cases. */
	xd = (t_f64)x;
	abstop = top12_f32(x) & 0x7ff;
	if (predict_false(abstop >= top12_f32(88.0f))) /* |x| >= 88 or x is nan. */
	{
		if (AS_U32(x) == AS_U32(-INFINITY))
			return 0.0f;
		if (abstop >= top12_f32(INFINITY))
			return x + x;
		if (x > 0x1.62e42ep6f) /* x > log(0x1p128) ~= 88.72 */
			return __math_oflowf(0);
		if (x < -0x1.9fe368p6f) /* x < log(0x1p-150) ~= -103.97 */
			return __math_uflowf(0);
	}

	/* x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k. */
	z = __exp_data.invln2N * xd;

	/* Round and convert z to int, the result is in [-150*N, 128*N] and
	   ideally ties-to-even rule is used, otherwise the magnitude of r
	   can be bigger which gives larger approximation error. */
#if TOINT_INTRINSICS
	kd = roundtoint(z);
	ki = converttoint(z);
#else
# define SHIFT __expf_data.shift
	kd = (z + SHIFT);
	ki = AS_U64(kd);
	kd -= SHIFT;
#endif
	r = z - kd;
	/* exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1) */
	t = __expf_data.table[ki % N_F32];
	t += ki << (52 - EXP2F_TABLE_BITS);
	s = AS_F64(t);
	z = __expf_data.poly[0] * r + __expf_data.poly[1];
	r2 = r * r;
	y = __expf_data.poly[2] * r + 1;
	y = z * r2 + y;
	y = y * s;
	return (t_f32)(y);
}

t_f64	F64_Exp(t_f64 x)
{
	t_u32 abstop;
	t_u64 ki, idx, top, sbits;
	t_f64 kd, z, r, r2, scale, tail, tmp;
	/* Filter out exceptional cases. */
	abstop = top12_f64(x) & 0x7ff;
	if (predict_false(abstop - top12_f64(0x1p-54) >= top12_f64(512.0) - top12_f64(0x1p-54)))
	{
		if (abstop - top12_f64(0x1p-54) >= 0x80000000) /* Avoid spurious underflow for tiny x. */
			return WANT_ROUNDING ? 1.0 + x : 1.0; /* Note: 0 is common input. */
		if (abstop >= top12_f64(1024.0))
		{
			if (AS_U64(x) == AS_U64(-INFINITY))
				return 0.0;
			if (abstop >= top12_f64(INFINITY))
				return 1.0 + x;
			if (AS_U64(x) >> 63)
				return __math_uflow(0);
			else
				return __math_oflow(0);
		}
		/* Large x is special cased below. */
		abstop = 0;
	}
	/* exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]. */
	/* x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]. */
	z = __exp_data.invln2N * x;
#if TOINT_INTRINSICS
	kd = roundtoint(z);
	ki = converttoint(z);
#elif EXP_USE_TOINT_NARROW
	/* z - kd is in [-0.5-2^-16, 0.5] in all rounding modes. */
	kd = (z + __exp_data.exp_shift);
	ki = AS_U64(kd) >> 16;
	kd = (t_f64)(int32_t)ki;
#else
	/* z - kd is in [-1, 1] in non-nearest rounding modes. */
	kd = (z + __exp_data.exp_shift);
	ki = AS_U64(kd);
	kd -= __exp_data.exp_shift;
#endif
	r = x + kd * __exp_data.negln2hiN + kd * __exp_data.negln2loN;
	/* 2^(k/N) ~= scale * (1 + tail). */
	idx = 2 * (ki % N_F64);
	top = ki << (52 - EXP_TABLE_BITS);
	tail = AS_F64(__exp_data.table[idx]);
	/* This is only a valid scale when -1023*N < k < 1024*N. */
	sbits = __exp_data.table[idx + 1] + top;
	/* exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1). */
	/* Evaluation is optimized assuming superscalar pipelined execution. */
	r2 = r * r;
	/* Without fma the worst case error is 0.25/N ulp larger. */
	/* Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp. */
	tmp = tail + r + r2 * (__exp_data.exp_poly[1] + r * __exp_data.exp_poly[2]) + r2 * r2 * (__exp_data.exp_poly[3] + r * __exp_data.exp_poly[4]);
	if (predict_false(abstop == 0))
		return specialcase(tmp, sbits, ki);
	scale = AS_F64(sbits);
	/* Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there
	   is no spurious underflow here even without fma. */
	return (t_f64)(scale + scale * tmp);
}

#if LIBCONFIG_USE_FLOAT80
static const t_f80 P[3] =
{
 1.2617719307481059087798E-4L,
 3.0299440770744196129956E-2L,
 9.9999999999999999991025E-1L,
};
static const t_f80 Q[4] =
{
 3.0019850513866445504159E-6L,
 2.5244834034968410419224E-3L,
 2.2726554820815502876593E-1L,
 2.0000000000000000000897E0L,
};
static const t_f80
LN2HI = 6.9314575195312500000000E-1L,
LN2LO = 1.4286068203094172321215E-6L,
LOG2E = 1.4426950408889634073599E0L;

t_f80	F80_Exp(t_f80 x)
{
	t_f80 px, xx;
	int k;

	if (isnan(x))
		return x;
	if (x > 11356.5234062941439488L) /* x > ln(2^16384 - 0.5) */
		return x * 0x1p16383L;
	if (x < -11399.4985314888605581L) /* x < ln(2^-16446) */
		return -0x1p-16445L/x;

	/* Express e**x = e**f 2**k
	 *   = e**(f + k ln(2))
	 */
	px = floorl(LOG2E * x + 0.5);
	k = px;
	x -= px * LN2HI;
	x -= px * LN2LO;

	/* rational approximation of the fractional part:
	 * e**x =  1 + 2x P(x**2)/(Q(x**2) - x P(x**2))
	 */
	xx = x * x;
	px = x * __polevll(xx, P, 2);
	x = px/(__polevll(xx, Q, 3) - px);
	x = 1.0 + 2.0 * x;
	return scalbnl(x, k);
}
#endif

#if LIBCONFIG_USE_FLOAT128
#endif



#endif
