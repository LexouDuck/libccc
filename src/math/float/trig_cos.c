
#include "libccc/math.h"
#include "libccc/memory.h"

#include LIBCONFIG_ERROR_INCLUDE



#if LIBCONFIG_USE_STD_MATH
MATH_DECL_REALFUNCTION(Cos, cos)
#elif 1 // LIBCONFIG_USE_CCC_MATH
static t_float	inv_factorial(t_uint n)
{
	static const t_float	result[16] =
	{
		1.0,
		1.0,
		1.0 / 2,
		1.0 / 6,
		1.0 / 24,
		1.0 / 120,
		1.0 / 720,
		1.0 / 5040,
		1.0 / 40320,
		1.0 / 362880,
		1.0 / 3628800,
		1.0 / 39916800,
		1.0 / 479001600,
		1.0 / 6227020800,
		1.0 / 87178291200,
		1.0 / 1307674368000,
	};
	return (result[n]); //static so it shouldn't be called with any weird values
//	return (n >= 16) ? 0. : result[n];
}
// taylor series approximation
#define DEFINEFUNC_FLOAT_COS(BITS) \
t_f##BITS	F##BITS##_Cos(t_f##BITS x)					\
{														\
	t_f##BITS	result;									\
	t_bool		sign; /* `TRUE` for negative */			\
	t_f##BITS	x_pow2;									\
	t_f##BITS	x_pow4;									\
	t_f##BITS	x_pow6;									\
	t_f##BITS	x_pow8;									\
	if CCCERROR(IS_NAN(x), ERROR_NANARGUMENT, NULL)		\
		return (NAN);									\
	sign = 0;											\
	if (x < 0.)											\
		x = -x;											\
	if (x > TAU)										\
		x = F##BITS##_Mod(x, TAU);						\
	if (x > PI)											\
		x = PI - (x - PI);								\
	if (x > PI_HALF)									\
	{													\
		x = PI_HALF - (x - PI_HALF);					\
		sign = -1;										\
	}													\
	x_pow2 = x * x;										\
	x_pow4 = x_pow2 * x_pow2;							\
	x_pow6 = x_pow2 * x_pow4;							\
	x_pow8 = x_pow4 * x_pow4;							\
	result = 1.;										\
	result -= x_pow2 * inv_factorial(2);				\
	result += x_pow4 * inv_factorial(4);				\
	result -= x_pow6 * inv_factorial(6);				\
	result += x_pow8 * inv_factorial(8);				\
	result -= x_pow8 * x_pow2 * inv_factorial(10);		\
	result += x_pow8 * x_pow4 * inv_factorial(12);		\
	result -= x_pow8 * x_pow6 * inv_factorial(14);		\
	return (sign ? -result : result);					\
}

DEFINEFUNC_FLOAT_COS(32)
DEFINEFUNC_FLOAT_COS(64)
#if LIBCONFIG_USE_FLOAT80
DEFINEFUNC_FLOAT_COS(80)
#endif
#if LIBCONFIG_USE_FLOAT128
DEFINEFUNC_FLOAT_COS(128)
#endif



#else
/*
** ============================================================================
** Copyright (c) 1993 by Sun Microsystems, Inc. All rights reserved.
** Copyright (c) 2008 Steven G. Kargl, David Schultz, Bruce D. Evans.
**
** Developed at SunPro, a Sun Microsystems, Inc. business.
** Permission to use, copy, modify, and distribute this software
** is freely granted, provided that this notice is preserved.
** ============================================================================
*/



/* __cos(x, y)
**	kernel cos function on [-pi/4, pi/4], pi/4 ~ 0.785398164
**	Input x is assumed to be bounded by ~pi/4 in magnitude.
**	Input y is the tail of x.
**
**	Algorithm
**		1. Since cos(-x) = cos(x), we need only to consider positive x.
**		2. if x < 2^-27 (hx<0x3E400000 0), return 1 with inexact if x!=0.
**		3. cos(x) is approximated by a polynomial of degree 14 on [0,pi/4]
**			cos(x) ~ 1 - x*x/2 + C1*x^4+ ... + C6*x^14
**			where the remez error is
**			cos(x)-(1-.5*x^2+C1*x^4+C2*x^6+C3*x^8+C4*x^10+C5*x^12+C6*x^14)| <= 2
**
**		4. let r = C1*x^4+C2*x^6+C3*x^8+C4*x^10+C5*x^12+C6*x^14, then
**				cos(x) ~ 1 - x*x/2 + r
**			since
**				cos(x+y) ≈ cos(x) - sin(x)*y ≈ cos(x) - x*y,
**			a correction term is necessary in cos(x) and hence
**				cos(x+y) = 1 - (x*x/2 - (r - x*y))
**			For better accuracy, rearrange to
**				cos(x+y) ~ w + (tmp + (r-x*y))
**			where w = 1 - x*x/2 and tmp is a tiny correction term
**			(1 - x*x/2 == w + tmp exactly in infinite precision).
**			The exactness of w + tmp in infinite precision depends on w
**			and tmp having the same precision as x.  If they have extra
**			precision due to compiler bugs, then the extra precision is
**			only good provided it is retained in all terms of the final
**			expression for cos().  Retention happens in all cases tested
**			under FreeBSD, so don't pessimize things by forcibly clipping
**			any extra precision in w.
*/
/* ld80 version of __cos.c.  See __cos.c for most comments. */
/*
**	Domain [-0.7854, 0.7854]
**	range ~[-2.43e-23, 2.425e-23]:
**		|cos(x) - c(x)| < 2**-75.1
**
**		The coefficients of c(x) were generated by a pari-gp script using
**		a Remez algorithm that searches for the best higher coefficients
**		after rounding leading coefficients to a specified precision.
**
**		Simpler methods like Chebyshev or basic Remez barely suffice for
**		cos() in 64-bit precision, because we want the coefficient of x^2
**		to be precisely -0.5 so that multiplying by it is exact, and plain
**		rounding of the coefficients of a good polynomial approximation only
**		gives this up to about 64-bit precision.  Plain rounding also gives
**		a mediocre approximation for the coefficient of x^4, but a rounding
**		error of 0.5 ulps for this coefficient would only contribute ~0.01
**		ulps to the final error, so this is unimportant.
**		Rounding errors in higher coefficients are even less important.
**
**		In fact, coefficients above the x^4 one only need to have 53-bit
**		precision, and this is more efficient.  We get this optimization
**		almost for free from the complications needed to search for the best
**		higher coefficients.
*/
/* ld128 version of __cos.c.  See __cos.c for most comments. */
/*
**	Domain [-0.7854, 0.7854]
**	range ~[-1.80e-37, 1.79e-37]:
**		|cos(x) - c(x))| < 2**-122.0
**
**		113-bit precision requires more care than 64-bit precision, since
**		simple methods give a minimax polynomial with coefficient for x^2
**		that is 1 ulp below 0.5, but we want it to be precisely 0.5.
**		See above for more details.
*/

static
t_f32 __cos32(t_f64 x, t_f64 y)
{
	/* |cos(x) - c(x)| < 2**-34.1 (~[-5.37e-11, 5.295e-11]). */
	static const t_f64 C1 = -0x1FFFFFFD0C5E81.0p-54; /* -0.499999997251031003120 */
	static const t_f64 C2 = +0x155553E1053A42.0p-57; /* +0.0416666233237390631894 */
	static const t_f64 C3 = -0x16C087E80F1E27.0p-62; /* -0.00138867637746099294692 */
	static const t_f64 C4 = +0x199342E0EE5069.0p-68; /* +0.0000243904487962774090654 */
	t_f64 x2 = x * x;
	t_f64 polynomial = (x2*(C1+x2*(C2+x2*(C3+x2*C4))));
	t_f64 hx2 = 0.5 * x2;
	t_f64 mhx2 = 1.0 - hx2;
	return (mhx2 + (((1.0 - mhx2) - hx2) + (x2 * polynomial - x * y)));
}

static
t_f64 __cos64(t_f64 x, t_f64 y)
{
	static const t_f64 C1 = +4.16666666666666019037e-02; /* 0x3FA55555, 0x5555554C */
	static const t_f64 C2 = -1.38888888888741095749e-03; /* 0xBF56C16C, 0x16C15177 */
	static const t_f64 C3 = +2.48015872894767294178e-05; /* 0x3EFA01A0, 0x19CB1590 */
	static const t_f64 C4 = -2.75573143513906633035e-07; /* 0xBE927E4F, 0x809C52AD */
	static const t_f64 C5 = +2.08757232129817482790e-09; /* 0x3E21EE9E, 0xBDB4B1C4 */
	static const t_f64 C6 = -1.13596475577881948265e-11; /* 0xBDA8FAE9, 0xBE8838D4 */
	t_f64 x2 = x * x;
	t_f64 polynomial = (x2*(C1+x2*(C2+x2*(C3+x2*(C4+x2*(C5+x2*C6))))));
	t_f64 hx2 = 0.5 * x2;
	t_f64 mhx2 = 1.0 - hx2;
	return (mhx2 + (((1.0 - mhx2) - hx2) + (x2 * polynomial - x * y)));
}

#if LIBCONFIG_USE_FLOAT80
static
t_f80 __cos80(t_f80 x, t_f80 y)
{
	static const t_f80 C1 = +0.416666666666666666136e-1L; /* +0xAAAAAAAAAAAAAA9B.0p-68 */
	static const t_f64 C2 = -0.13888888888888874e-2;      /* -0x16C16C16C16C10.0p-62 */
	static const t_f64 C3 = +0.24801587301571716e-4;      /* +0x1A01A01A018E22.0p-68 */
	static const t_f64 C4 = -0.27557319215507120e-6;      /* -0x127E4FB7602F22.0p-74 */
	static const t_f64 C5 = +0.20876754400407278e-8;      /* +0x11EED8CAAECCF1.0p-81 */
	static const t_f64 C6 = -1.1470297442401303e-11;      /* -0x19393412BD1529.0p-89 */
	static const t_f64 C7 = +4.7383039476436467e-14;      /* +0x1AAC9D9AF5C43E.0p-97 */
	t_f80 x2 = x * x;
	t_f80 polynomial = (x2*(C1+x2*(C2+x2*(C3+x2*(C4+x2*(C5+x2*(C6+x2*C7)))))));
	t_f80 hx2 = 0.5 * x2;
	t_f80 mhx2 = 1.0 - hx2;
	return mhx2 + (((1.0 - mhx2) - hx2) + (x2 * polynomial - x * y));
}
#endif

#if LIBCONFIG_USE_FLOAT128
static
t_f128 __cos128(t_f128 x, t_f128 y)
{
	static const t_f128 C1  = +0.4166666666666666666666666666666658424671e-01L;
	static const t_f128 C2  = -0.1388888888888888888888888888863490893732e-02L;
	static const t_f128 C3  = +0.2480158730158730158730158600795304914210e-04L;
	static const t_f128 C4  = -0.2755731922398589065255474947078934284324e-06L;
	static const t_f128 C5  = +0.2087675698786809897659225313136400793948e-08L;
	static const t_f128 C6  = -0.1147074559772972315817149986812031204775e-10L;
	static const t_f128 C7  = +0.4779477332386808976875457937252120293400e-13L;
	static const t_f64  C8  = -0.1561920696721507929516718307820958119868e-15;
	static const t_f64  C9  = +0.4110317413744594971475941557607804508039e-18;
	static const t_f64  C10 = -0.8896592467191938803288521958313920156409e-21;
	static const t_f64  C11 = +0.1601061435794535138244346256065192782581e-23;
	t_f128 x2 = x * x;
	t_f128 polynomial = (x2*(C1+x2*(C2+x2*(C3+x2*(C4+x2*(C5+x2*(C6+x2*(C7+x2*(C8+x2*(C9+x2*(C10+x2*C11)))))))))));
	t_f128 hx2 = 0.5 * x2;
	t_f128 mhx2 = 1.0 - hx2;
	return mhx2 + (((1.0 - mhx2) - hx2) + (x2 * polynomial - x * y));
}
#endif



// taylor series approximation
#define DEFINEFUNC_FLOAT_COS(BITS) \
t_f##BITS	F##BITS##_Cos(t_f##BITS x) \
{ \
	if CCCERROR(IS_NAN(x), ERROR_NANARGUMENT, NULL) \
		return (NAN); \
	if (F##BITS##_Abs(x) < PI_HALF) \
		return __cos##BITS(x, 0); \
	if (F##BITS##_Mod(x + PI_HALF, PI_DOUBLE) < PI) \
		return +__cos##BITS(F##BITS##_Mod(x + PI_HALF, PI) - PI_HALF, 0); \
	else \
		return -__cos##BITS(F##BITS##_Mod(x + PI_HALF, PI) - PI_HALF, 0); \
} \

DEFINEFUNC_FLOAT_COS(32)
DEFINEFUNC_FLOAT_COS(64)
#if LIBCONFIG_USE_FLOAT80
DEFINEFUNC_FLOAT_COS(80)
#endif
#if LIBCONFIG_USE_FLOAT128
DEFINEFUNC_FLOAT_COS(128)
#endif

#endif



#if 0

/* cos(x)
**	Return cosine function of x.
**
**	kernel function:
**		__sin           ... sine function on [-pi/4,pi/4]
**		__cos           ... cosine function on [-pi/4,pi/4]
**		__rem_pio2      ... argument reduction routine
**
**	Method.
**		Let S,C and T denote the sin, cos and tan respectively on
**		[-PI/4, +PI/4]. Reduce the argument x to y1+y2 = x-k*pi/2
**		in [-pi/4 , +pi/4], and let n = k mod 4.
**		We have
**
**		| n |sin(x)|cos(x)|tan(x)|
**		|---|------|------|------|
**		| 0 | +sin | +cos | +tan |
**		| 1 | +cos | -sin |-1/tan|
**		| 2 | -sin | -cos | +tan |
**		| 3 | -cos | +sin |-1/tan|
**		|---|------|------|------|
**
**	Special cases:
**		Let trig be any of sin, cos, or tan.
**		trig(+-INF)  is NaN, with signals;
**		trig(NaN)    is that NaN;
**
**	Accuracy:
**		TRIG(x) returns trig(x) nearly rounded
*/

float cosf(float x)
{
	/* Small multiples of pi/2 rounded to double precision. */
	static const double c1pio2 = 1*PI_HALF; /* 0x3FF921FB, 0x54442D18 */
	static const double c2pio2 = 2*PI_HALF; /* 0x400921FB, 0x54442D18 */
	static const double c3pio2 = 3*PI_HALF; /* 0x4012D97C, 0x7F3321D2 */
	static const double c4pio2 = 4*PI_HALF; /* 0x401921FB, 0x54442D18 */
	double y;
	uint32_t ix;
	unsigned n, sign;

	GET_FLOAT_WORD(ix, x);
	sign = ix >> 31;
	ix &= 0x7FFFFFFF;

	if (ix <= 0x3F490FDA) /* |x| ~<= pi/4 */
	{
		if (ix < 0x39800000) /* |x| < 2**-12 */
		{
			/* raise inexact if x != 0 */
			FORCE_EVAL(x + 0x1p120f);
			return 1.0f;
		}
		return __cosdf(x);
	}
	if (ix <= 0x407B53D1) /* |x| ~<= 5*pi/4 */
	{
		if (ix > 0x4016CBE3) /* |x|  ~> 3*pi/4 */
			return -__cosdf(sign ? x+c2pio2 : x-c2pio2);
		else
		{
			if (sign)
				return __sindf(x + c1pio2);
			else
				return __sindf(c1pio2 - x);
		}
	}
	if (ix <= 0x40E231D5) /* |x| ~<= 9*pi/4 */
	{
		if (ix > 0x40AFEDDF) /* |x| ~> 7*pi/4 */
			return __cosdf(sign ? x+c4pio2 : x-c4pio2);
		else
		{
			if (sign)
				return __sindf(-x - c3pio2);
			else
				return __sindf(+x - c3pio2);
		}
	}

	/* cos(Inf or NaN) is NaN */
	if (ix >= 0x7F800000)
		return x-x;

	/* general argument reduction needed */
	n = __rem_pio2f(x,&y);
	switch (n&3)
	{
		case 0: return +__cosdf(+y);
		case 1: return +__sindf(-y);
		case 2: return -__cosdf(+y);
		case 3:	return +__sindf(+y);
		default:
			return  __sindf(y);
	}
}



double cos(double x)
{
	double y[2];
	uint32_t ix;
	unsigned n;

	GET_HIGH_WORD(ix, x);
	ix &= 0x7FFFFFFF;

	/* |x| ~< pi/4 */
	if (ix <= 0x3FE921FB)
	{
		if (ix < 0x3E46A09E) /* |x| < 2**-27 * sqrt(2) */
		{
			/* raise inexact if x!=0 */
			FORCE_EVAL(x + 0x1p120f);
			return 1.0;
		}
		return __cos(x, 0);
	}

	/* cos(Inf or NaN) is NaN */
	if (ix >= 0x7FF00000)
		return x-x;

	/* argument reduction */
	n = __rem_pio2(x, y);
	switch (n&3)
	{
		case 0: return +__cos(y[0], y[1]);
		case 1: return -__sin(y[0], y[1], 1);
		case 2: return -__cos(y[0], y[1]);
		case 3:	return +__sin(y[0], y[1], 1);
		default:
			return __sin(y[0], y[1], 1);
	}
}



union ldshape
{
	long double	f;
	struct {
	   uint64_t   lo;
	   uint32_t   mid;
	   uint16_t   top;
	   uint16_t   se;
	}	i;
	struct {
	   uint64_t   lo;
	   uint64_t   hi;
	}	i2;
};

#if (LDBL_MANT_DIG == 53 && LDBL_MAX_EXP == 1024)
long double cosl(long double x)
{
	return cos(x);
}
#elif (LDBL_MANT_DIG == 64 || LDBL_MANT_DIG == 113) && LDBL_MAX_EXP == 16384
long double cosl(long double x)
{
	union ldshape u = {x};
	unsigned n;
	long double y[2], hi, lo;

	u.i.se &= 0x7FFF;
	if (u.i.se == 0x7FFF)
		return x - x;
	x = u.f;
	if (x < PI_QUARTER)
	{
		if (u.i.se < 0x3FFF - LDBL_MANT_DIG)
			/* raise inexact if x!=0 */
			return 1.0 + x;
		return __cosl(x, 0);
	}
	n = __rem_pio2l(x, y);
	hi = y[0];
	lo = y[1];
	switch (n & 3)
	{
		case 0:	return +__cosl(hi, lo);
		case 1:	return -__sinl(hi, lo, 1);
		case 2:	return -__cosl(hi, lo);
		case 3:	return +__sinl(hi, lo, 1);
		default:
			return __sinl(hi, lo, 1);
	}
}
#endif

#endif
